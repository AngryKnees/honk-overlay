/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/tmi.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/tmi.js/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var client = __webpack_require__(/*! ./lib/client */ \"./node_modules/tmi.js/lib/client.js\");\nmodule.exports = {\n\tclient,\n\tClient: client\n};\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/index.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/api.js":
/*!****************************************!*\
  !*** ./node_modules/tmi.js/lib/api.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fetch = __webpack_require__(/*! node-fetch */ \"?7581\");\nvar _ = __webpack_require__(/*! ./utils */ \"./node_modules/tmi.js/lib/utils.js\");\n\nvar api = function api(options, callback) {\n\t// Set the url to options.uri or options.url..\n\tvar url = options.url !== undefined ? options.url : options.uri;\n\n\t// Make sure it is a valid url..\n\tif(!_.isURL(url)) {\n\t\turl = `https://api.twitch.tv/kraken${url[0] === \"/\" ? url : `/${url}`}`;\n\t}\n\n\t// We are inside a Node application, so we can use the node-fetch module..\n\tif(_.isNode()) {\n\t\tvar opts = _.merge({ method: \"GET\", json: true }, options, { url });\n\t\tvar url = opts.url;\n\t\tif(opts.qs) {\n\t\t\tvar qs = new URLSearchParams(opts.qs);\n\t\t\turl += `?${qs}`;\n\t\t}\n\t\tvar response = {};\n\t\t/** @type {ReturnType<import('node-fetch')['default']>} */\n\t\tconst fetchPromise = fetch(url, {\n\t\t\tmethod: opts.method,\n\t\t\theaders: opts.headers,\n\t\t\tbody: opts.body\n\t\t});\n\t\tfetchPromise.then(res => {\n\t\t\tresponse = { statusCode: res.status, headers: res.headers };\n\t\t\treturn opts.json ? res.json() : res.text();\n\t\t})\n\t\t.then(\n\t\t\tdata => callback(null, response, data),\n\t\t\terr => callback(err, response, null)\n\t\t);\n\t}\n\t// Web application, extension, React Native etc.\n\telse {\n\t\tvar opts = _.merge({ method: \"GET\", headers: {} }, options, { url });\n\t\t// prepare request\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open(opts.method, opts.url, true);\n\t\tfor(var name in opts.headers) {\n\t\t\txhr.setRequestHeader(name, opts.headers[name]);\n\t\t}\n\t\txhr.responseType = \"json\";\n\t\t// set request handler\n\t\txhr.addEventListener(\"load\", ev => {\n\t\t\tif(xhr.readyState == 4) {\n\t\t\t\tif(xhr.status != 200) {\n\t\t\t\t\tcallback(xhr.status, null, null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(null, null, xhr.response);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// submit\n\t\txhr.send();\n\t}\n}\n\nmodule.exports = api;\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/api.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/client.js":
/*!*******************************************!*\
  !*** ./node_modules/tmi.js/lib/client.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var api = __webpack_require__(/*! ./api */ \"./node_modules/tmi.js/lib/api.js\");\nvar commands = __webpack_require__(/*! ./commands */ \"./node_modules/tmi.js/lib/commands.js\");\nvar EventEmitter = __webpack_require__(/*! ./events */ \"./node_modules/tmi.js/lib/events.js\").EventEmitter;\nvar logger = __webpack_require__(/*! ./logger */ \"./node_modules/tmi.js/lib/logger.js\");\nvar parse = __webpack_require__(/*! ./parser */ \"./node_modules/tmi.js/lib/parser.js\");\nvar timer = __webpack_require__(/*! ./timer */ \"./node_modules/tmi.js/lib/timer.js\");\nvar _global = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : {};\nvar _WebSocket = _global.WebSocket || __webpack_require__(/*! ws */ \"?98fa\");\nvar _ = __webpack_require__(/*! ./utils */ \"./node_modules/tmi.js/lib/utils.js\");\n\n// Client instance..\nvar client = function client(opts) {\n\tif(this instanceof client === false) { return new client(opts); }\n\n\tthis.opts = _.get(opts, {});\n\tthis.opts.channels = this.opts.channels || [];\n\tthis.opts.connection = this.opts.connection || {};\n\tthis.opts.identity = this.opts.identity || {};\n\tthis.opts.options = this.opts.options || {};\n\n\tthis.clientId = _.get(this.opts.options.clientId, null);\n\tthis._globalDefaultChannel = _.channel(_.get(this.opts.options.globalDefaultChannel, \"#tmijs\"));\n\n\tthis.maxReconnectAttempts = _.get(this.opts.connection.maxReconnectAttempts, Infinity);\n\tthis.maxReconnectInterval = _.get(this.opts.connection.maxReconnectInterval, 30000);\n\tthis.reconnect = _.get(this.opts.connection.reconnect, false);\n\tthis.reconnectDecay = _.get(this.opts.connection.reconnectDecay, 1.5);\n\tthis.reconnectInterval = _.get(this.opts.connection.reconnectInterval, 1000);\n\n\tthis.reconnecting = false;\n\tthis.reconnections = 0;\n\tthis.reconnectTimer = this.reconnectInterval;\n\n\tthis.secure = _.get(\n\t\tthis.opts.connection.secure,\n\t\t!this.opts.connection.server && !this.opts.connection.port\n\t);\n\n\t// Raw data and object for emote-sets..\n\tthis.emotes = \"\";\n\tthis.emotesets = {};\n\n\tthis.channels = [];\n\tthis.currentLatency = 0;\n\tthis.globaluserstate = {};\n\tthis.lastJoined = \"\";\n\tthis.latency = new Date();\n\tthis.moderators = {};\n\tthis.pingLoop = null;\n\tthis.pingTimeout = null;\n\tthis.reason = \"\";\n\tthis.username = \"\";\n\tthis.userstate = {};\n\tthis.wasCloseCalled = false;\n\tthis.ws = null;\n\n\t// Create the logger..\n\tvar level = \"error\";\n\tif(this.opts.options.debug) { level = \"info\"; }\n\tthis.log = this.opts.logger || logger;\n\n\ttry { logger.setLevel(level); } catch(e) {};\n\n\t// Format the channel names..\n\tthis.opts.channels.forEach(function(part, index, theArray) {\n\t\ttheArray[index] = _.channel(part);\n\t});\n\n\tEventEmitter.call(this);\n\tthis.setMaxListeners(0);\n}\n\n_.inherits(client, EventEmitter);\n\n// Emit multiple events..\nclient.prototype.emits = function emits(types, values) {\n\tfor (var i = 0; i < types.length; i++) {\n\t\tvar val = i < values.length ? values[i] : values[values.length - 1];\n\t\tthis.emit.apply(this, [types[i]].concat(val));\n\t}\n};\n\nclient.prototype.off = client.prototype.removeListener;\n\nclient.prototype.api = api;\n\n// Put all commands in prototype..\nfor(var methodName in commands) {\n\tclient.prototype[methodName] = commands[methodName];\n}\n\n// Handle parsed chat server message..\nclient.prototype.handleMessage = function handleMessage(message) {\n\tif(_.isNull(message)) {\n\t\treturn;\n\t}\n\n\tif(this.listenerCount(\"raw_message\")) {\n\t\tthis.emit(\"raw_message\", JSON.parse(JSON.stringify(message)), message);\n\t}\n\n\tvar channel = _.channel(_.get(message.params[0], null));\n\tvar msg = _.get(message.params[1], null);\n\tvar msgid = _.get(message.tags[\"msg-id\"], null);\n\n\t// Parse badges, badge-info and emotes..\n\tvar tags = message.tags = parse.badges(parse.badgeInfo(parse.emotes(message.tags)));\n\n\t// Transform IRCv3 tags..\n\tfor(var key in tags) {\n\t\tif(key === \"emote-sets\" || key === \"ban-duration\" || key === \"bits\") {\n\t\t\tcontinue;\n\t\t}\n\t\tvar value = tags[key];\n\t\tif(_.isBoolean(value)) { value = null; }\n\t\telse if(value === \"1\") { value = true; }\n\t\telse if(value === \"0\") { value = false; }\n\t\telse if(_.isString(value)) { value = _.unescapeIRC(value); }\n\t\ttags[key] = value;\n\t}\n\n\t// Messages with no prefix..\n\tif(_.isNull(message.prefix)) {\n\t\tswitch(message.command) {\n\t\t\t// Received PING from server..\n\t\t\tcase \"PING\":\n\t\t\t\tthis.emit(\"ping\");\n\t\t\t\tif(this._isConnected()) {\n\t\t\t\t\tthis.ws.send(\"PONG\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Received PONG from server, return current latency..\n\t\t\tcase \"PONG\":\n\t\t\t\tvar currDate = new Date();\n\t\t\t\tthis.currentLatency = (currDate.getTime() - this.latency.getTime()) / 1000;\n\t\t\t\tthis.emits([\"pong\", \"_promisePing\"], [[this.currentLatency]]);\n\n\t\t\t\tclearTimeout(this.pingTimeout);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.log.warn(`Could not parse message with no prefix:\\n${JSON.stringify(message, null, 4)}`);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Messages with \"tmi.twitch.tv\" as a prefix..\n\telse if(message.prefix === \"tmi.twitch.tv\") {\n\t\tswitch(message.command) {\n\t\t\tcase \"002\":\n\t\t\tcase \"003\":\n\t\t\tcase \"004\":\n\t\t\tcase \"372\":\n\t\t\tcase \"375\":\n\t\t\tcase \"CAP\":\n\t\t\t\tbreak;\n\n\t\t\t// Retrieve username from server..\n\t\t\tcase \"001\":\n\t\t\t\tthis.username = message.params[0];\n\t\t\t\tbreak;\n\n\t\t\t// Connected to server..\n\t\t\tcase \"376\":\n\t\t\t\tthis.log.info(\"Connected to server.\");\n\t\t\t\tthis.userstate[this._globalDefaultChannel] = {};\n\t\t\t\tthis.emits([\"connected\", \"_promiseConnect\"], [[this.server, this.port], [null]]);\n\t\t\t\tthis.reconnections = 0;\n\t\t\t\tthis.reconnectTimer = this.reconnectInterval;\n\n\t\t\t\t// Set an internal ping timeout check interval..\n\t\t\t\tthis.pingLoop = setInterval(() => {\n\t\t\t\t\t// Make sure the connection is opened before sending the message..\n\t\t\t\t\tif(this._isConnected()) {\n\t\t\t\t\t\tthis.ws.send(\"PING\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.latency = new Date();\n\t\t\t\t\tthis.pingTimeout = setTimeout(() => {\n\t\t\t\t\t\tif(!_.isNull(this.ws)) {\n\t\t\t\t\t\t\tthis.wasCloseCalled = false;\n\t\t\t\t\t\t\tthis.log.error(\"Ping timeout.\");\n\t\t\t\t\t\t\tthis.ws.close();\n\n\t\t\t\t\t\t\tclearInterval(this.pingLoop);\n\t\t\t\t\t\t\tclearTimeout(this.pingTimeout);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, _.get(this.opts.connection.timeout, 9999));\n\t\t\t\t}, 60000);\n\n\t\t\t\t// Join all the channels from the config with an interval..\n\t\t\t\tvar joinInterval = _.get(this.opts.options.joinInterval, 2000);\n\t\t\t\tif(joinInterval < 300) joinInterval = 300;\n\t\t\t\tvar joinQueue = new timer.queue(joinInterval);\n\t\t\t\tvar joinChannels = _.union(this.opts.channels, this.channels);\n\t\t\t\tthis.channels = [];\n\n\t\t\t\tfor (var i = 0; i < joinChannels.length; i++) {\n\t\t\t\t\tlet channel = joinChannels[i];\n\t\t\t\t\tjoinQueue.add(() => {\n\t\t\t\t\t\tif(this._isConnected()) {\n\t\t\t\t\t\t\tthis.join(channel).catch(err => this.log.error(err));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tjoinQueue.run();\n\t\t\t\tbreak;\n\n\t\t\t// https://github.com/justintv/Twitch-API/blob/master/chat/capabilities.md#notice\n\t\t\tcase \"NOTICE\":\n\t\t\t\tvar nullArr = [null];\n\t\t\t\tvar noticeArr = [channel, msgid, msg];\n\t\t\t\tvar msgidArr = [msgid];\n\t\t\t\tvar channelTrueArr = [channel, true];\n\t\t\t\tvar channelFalseArr = [channel, false];\n\t\t\t\tvar noticeAndNull = [noticeArr, nullArr];\n\t\t\t\tvar noticeAndMsgid = [noticeArr, msgidArr];\n\t\t\t\tvar basicLog = `[${channel}] ${msg}`;\n\t\t\t\tswitch(msgid) {\n\t\t\t\t\t// This room is now in subscribers-only mode.\n\t\t\t\t\tcase \"subs_on\":\n\t\t\t\t\t\tthis.log.info(`[${channel}] This room is now in subscribers-only mode.`);\n\t\t\t\t\t\tthis.emits([\"subscriber\", \"subscribers\", \"_promiseSubscribers\"], [channelTrueArr, channelTrueArr, nullArr]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// This room is no longer in subscribers-only mode.\n\t\t\t\t\tcase \"subs_off\":\n\t\t\t\t\t\tthis.log.info(`[${channel}] This room is no longer in subscribers-only mode.`);\n\t\t\t\t\t\tthis.emits([\"subscriber\", \"subscribers\", \"_promiseSubscribersoff\"], [channelFalseArr, channelFalseArr, nullArr]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// This room is now in emote-only mode.\n\t\t\t\t\tcase \"emote_only_on\":\n\t\t\t\t\t\tthis.log.info(`[${channel}] This room is now in emote-only mode.`);\n\t\t\t\t\t\tthis.emits([\"emoteonly\", \"_promiseEmoteonly\"], [channelTrueArr, nullArr]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// This room is no longer in emote-only mode.\n\t\t\t\t\tcase \"emote_only_off\":\n\t\t\t\t\t\tthis.log.info(`[${channel}] This room is no longer in emote-only mode.`);\n\t\t\t\t\t\tthis.emits([\"emoteonly\", \"_promiseEmoteonlyoff\"], [channelFalseArr, nullArr]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Do not handle slow_on/off here, listen to the ROOMSTATE notice instead as it returns the delay.\n\t\t\t\t\tcase \"slow_on\":\n\t\t\t\t\tcase \"slow_off\":\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Do not handle followers_on/off here, listen to the ROOMSTATE notice instead as it returns the delay.\n\t\t\t\t\tcase \"followers_on_zero\":\n\t\t\t\t\tcase \"followers_on\":\n\t\t\t\t\tcase \"followers_off\":\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// This room is now in r9k mode.\n\t\t\t\t\tcase \"r9k_on\":\n\t\t\t\t\t\tthis.log.info(`[${channel}] This room is now in r9k mode.`);\n\t\t\t\t\t\tthis.emits([\"r9kmode\", \"r9kbeta\", \"_promiseR9kbeta\"], [channelTrueArr, channelTrueArr, nullArr]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// This room is no longer in r9k mode.\n\t\t\t\t\tcase \"r9k_off\":\n\t\t\t\t\t\tthis.log.info(`[${channel}] This room is no longer in r9k mode.`);\n\t\t\t\t\t\tthis.emits([\"r9kmode\", \"r9kbeta\", \"_promiseR9kbetaoff\"], [channelFalseArr, channelFalseArr, nullArr]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// The moderators of this room are: [..., ...]\n\t\t\t\t\tcase \"room_mods\":\n\t\t\t\t\t\tvar mods = msg.split(\": \")[1].toLowerCase()\n\t\t\t\t\t\t\t.split(\", \")\n\t\t\t\t\t\t\t.filter(n => n);\n\n\t\t\t\t\t\tthis.emits([\"_promiseMods\", \"mods\"], [[null, mods], [channel, mods]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// There are no moderators for this room.\n\t\t\t\t\tcase \"no_mods\":\n\t\t\t\t\t\tthis.emits([\"_promiseMods\", \"mods\"], [[null, []], [channel, []]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// The VIPs of this channel are: [..., ...]\n\t\t\t\t\tcase \"vips_success\":\n\t\t\t\t\t\tif(msg.endsWith(\".\")) {\n\t\t\t\t\t\t\tmsg = msg.slice(0, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar vips = msg.split(\": \")[1].toLowerCase()\n\t\t\t\t\t\t\t.split(\", \")\n\t\t\t\t\t\t\t.filter(n => n);\n\n\t\t\t\t\t\t\tthis.emits([\"_promiseVips\", \"vips\"], [[null, vips], [channel, vips]]);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// There are no VIPs for this room.\n\t\t\t\t\tcase \"no_vips\":\n\t\t\t\t\t\tthis.emits([\"_promiseVips\", \"vips\"], [[null, []], [channel, []]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Ban command failed..\n\t\t\t\t\tcase \"already_banned\":\n\t\t\t\t\tcase \"bad_ban_admin\":\n\t\t\t\t\tcase \"bad_ban_broadcaster\":\n\t\t\t\t\tcase \"bad_ban_global_mod\":\n\t\t\t\t\tcase \"bad_ban_self\":\n\t\t\t\t\tcase \"bad_ban_staff\":\n\t\t\t\t\tcase \"usage_ban\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseBan\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Ban command success..\n\t\t\t\t\tcase \"ban_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseBan\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Clear command failed..\n\t\t\t\t\tcase \"usage_clear\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseClear\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Mods command failed..\n\t\t\t\t\tcase \"usage_mods\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseMods\"], [noticeArr, [msgid, []]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Mod command success..\n\t\t\t\t\tcase \"mod_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseMod\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// VIPs command failed..\n\t\t\t\t\tcase \"usage_vips\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseVips\"], [noticeArr, [msgid, []]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// VIP command failed..\n\t\t\t\t\tcase \"usage_vip\":\n\t\t\t\t\tcase \"bad_vip_grantee_banned\":\n\t\t\t\t\tcase \"bad_vip_grantee_already_vip\":\n\t\t\t\t\tcase \"bad_vip_max_vips_reached\":\n\t\t\t\t\tcase \"bad_vip_achievement_incomplete\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseVip\"], [noticeArr, [msgid, []]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// VIP command success..\n\t\t\t\t\tcase \"vip_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseVip\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Mod command failed..\n\t\t\t\t\tcase \"usage_mod\":\n\t\t\t\t\tcase \"bad_mod_banned\":\n\t\t\t\t\tcase \"bad_mod_mod\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseMod\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unmod command success..\n\t\t\t\t\tcase \"unmod_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseUnmod\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unvip command success...\n\t\t\t\t\tcase \"unvip_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseUnvip\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unmod command failed..\n\t\t\t\t\tcase \"usage_unmod\":\n\t\t\t\t\tcase \"bad_unmod_mod\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseUnmod\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unvip command failed..\n\t\t\t\t\tcase \"usage_unvip\":\n\t\t\t\t\tcase \"bad_unvip_grantee_not_vip\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseUnvip\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Color command success..\n\t\t\t\t\tcase \"color_changed\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseColor\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Color command failed..\n\t\t\t\t\tcase \"usage_color\":\n\t\t\t\t\tcase \"turbo_only_color\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseColor\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Commercial command success..\n\t\t\t\t\tcase \"commercial_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseCommercial\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Commercial command failed..\n\t\t\t\t\tcase \"usage_commercial\":\n\t\t\t\t\tcase \"bad_commercial_error\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseCommercial\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Host command success..\n\t\t\t\t\tcase \"hosts_remaining\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tvar remainingHost = (!isNaN(msg[0]) ? parseInt(msg[0]) : 0);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseHost\"], [noticeArr, [null, ~~remainingHost]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Host command failed..\n\t\t\t\t\tcase \"bad_host_hosting\":\n\t\t\t\t\tcase \"bad_host_rate_exceeded\":\n\t\t\t\t\tcase \"bad_host_error\":\n\t\t\t\t\tcase \"usage_host\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseHost\"], [noticeArr, [msgid, null]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// r9kbeta command failed..\n\t\t\t\t\tcase \"already_r9k_on\":\n\t\t\t\t\tcase \"usage_r9k_on\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseR9kbeta\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// r9kbetaoff command failed..\n\t\t\t\t\tcase \"already_r9k_off\":\n\t\t\t\t\tcase \"usage_r9k_off\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseR9kbetaoff\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Timeout command success..\n\t\t\t\t\tcase \"timeout_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseTimeout\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"delete_message_success\":\n\t\t\t\t\t\tthis.log.info(`[${channel} ${msg}]`);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseDeletemessage\"], noticeAndNull);\n\n\t\t\t\t\t// Subscribersoff command failed..\n\t\t\t\t\tcase \"already_subs_off\":\n\t\t\t\t\tcase \"usage_subs_off\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseSubscribersoff\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Subscribers command failed..\n\t\t\t\t\tcase \"already_subs_on\":\n\t\t\t\t\tcase \"usage_subs_on\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseSubscribers\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Emoteonlyoff command failed..\n\t\t\t\t\tcase \"already_emote_only_off\":\n\t\t\t\t\tcase \"usage_emote_only_off\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseEmoteonlyoff\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Emoteonly command failed..\n\t\t\t\t\tcase \"already_emote_only_on\":\n\t\t\t\t\tcase \"usage_emote_only_on\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseEmoteonly\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Slow command failed..\n\t\t\t\t\tcase \"usage_slow_on\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseSlow\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Slowoff command failed..\n\t\t\t\t\tcase \"usage_slow_off\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseSlowoff\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Timeout command failed..\n\t\t\t\t\tcase \"usage_timeout\":\n\t\t\t\t\tcase \"bad_timeout_admin\":\n\t\t\t\t\tcase \"bad_timeout_broadcaster\":\n\t\t\t\t\tcase \"bad_timeout_duration\":\n\t\t\t\t\tcase \"bad_timeout_global_mod\":\n\t\t\t\t\tcase \"bad_timeout_self\":\n\t\t\t\t\tcase \"bad_timeout_staff\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseTimeout\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unban command success..\n\t\t\t\t\t// Unban can also be used to cancel an active timeout.\n\t\t\t\t\tcase \"untimeout_success\":\n\t\t\t\t\tcase \"unban_success\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseUnban\"], noticeAndNull);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unban command failed..\n\t\t\t\t\tcase \"usage_unban\":\n\t\t\t\t\tcase \"bad_unban_no_ban\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseUnban\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Delete command failed..\n\t\t\t\t\tcase \"usage_delete\":\n\t\t\t\t\tcase \"bad_delete_message_error\":\n\t\t\t\t\tcase \"bad_delete_message_broadcaster\":\n\t\t\t\t\tcase \"bad_delete_message_mod\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseDeletemessage\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unhost command failed..\n\t\t\t\t\tcase \"usage_unhost\":\n\t\t\t\t\tcase \"not_hosting\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseUnhost\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Whisper command failed..\n\t\t\t\t\tcase \"whisper_invalid_login\":\n\t\t\t\t\tcase \"whisper_invalid_self\":\n\t\t\t\t\tcase \"whisper_limit_per_min\":\n\t\t\t\t\tcase \"whisper_limit_per_sec\":\n\t\t\t\t\tcase \"whisper_restricted\":\n\t\t\t\t\tcase \"whisper_restricted_recipient\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\"notice\", \"_promiseWhisper\"], noticeAndMsgid);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Permission error..\n\t\t\t\t\tcase \"no_permission\":\n\t\t\t\t\tcase \"msg_banned\":\n\t\t\t\t\tcase \"msg_room_not_found\":\n\t\t\t\t\tcase \"msg_channel_suspended\":\n\t\t\t\t\tcase \"tos_ban\":\n\t\t\t\t\tcase \"invalid_user\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emits([\n\t\t\t\t\t\t\t\"notice\",\n\t\t\t\t\t\t\t\"_promiseBan\",\n\t\t\t\t\t\t\t\"_promiseClear\",\n\t\t\t\t\t\t\t\"_promiseUnban\",\n\t\t\t\t\t\t\t\"_promiseTimeout\",\n\t\t\t\t\t\t\t\"_promiseDeletemessage\",\n\t\t\t\t\t\t\t\"_promiseMods\",\n\t\t\t\t\t\t\t\"_promiseMod\",\n\t\t\t\t\t\t\t\"_promiseUnmod\",\n\t\t\t\t\t\t\t\"_promiseVips\",\n\t\t\t\t\t\t\t\"_promiseVip\",\n\t\t\t\t\t\t\t\"_promiseUnvip\",\n\t\t\t\t\t\t\t\"_promiseCommercial\",\n\t\t\t\t\t\t\t\"_promiseHost\",\n\t\t\t\t\t\t\t\"_promiseUnhost\",\n\t\t\t\t\t\t\t\"_promiseJoin\",\n\t\t\t\t\t\t\t\"_promisePart\",\n\t\t\t\t\t\t\t\"_promiseR9kbeta\",\n\t\t\t\t\t\t\t\"_promiseR9kbetaoff\",\n\t\t\t\t\t\t\t\"_promiseSlow\",\n\t\t\t\t\t\t\t\"_promiseSlowoff\",\n\t\t\t\t\t\t\t\"_promiseFollowers\",\n\t\t\t\t\t\t\t\"_promiseFollowersoff\",\n\t\t\t\t\t\t\t\"_promiseSubscribers\",\n\t\t\t\t\t\t\t\"_promiseSubscribersoff\",\n\t\t\t\t\t\t\t\"_promiseEmoteonly\",\n\t\t\t\t\t\t\t\"_promiseEmoteonlyoff\",\n\t\t\t\t\t\t\t\"_promiseWhisper\"\n\t\t\t\t\t\t], [noticeArr, [msgid, channel]]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Automod-related..\n\t\t\t\t\tcase \"msg_rejected\":\n\t\t\t\t\tcase \"msg_rejected_mandatory\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emit(\"automod\", channel, msgid, msg);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Unrecognized command..\n\t\t\t\t\tcase \"unrecognized_cmd\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emit(\"notice\", channel, msgid, msg);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Send the following msg-ids to the notice event listener..\n\t\t\t\t\tcase \"cmds_available\":\n\t\t\t\t\tcase \"host_target_went_offline\":\n\t\t\t\t\tcase \"msg_censored_broadcaster\":\n\t\t\t\t\tcase \"msg_duplicate\":\n\t\t\t\t\tcase \"msg_emoteonly\":\n\t\t\t\t\tcase \"msg_verified_email\":\n\t\t\t\t\tcase \"msg_ratelimit\":\n\t\t\t\t\tcase \"msg_subsonly\":\n\t\t\t\t\tcase \"msg_timedout\":\n\t\t\t\t\tcase \"msg_bad_characters\":\n\t\t\t\t\tcase \"msg_channel_blocked\":\n\t\t\t\t\tcase \"msg_facebook\":\n\t\t\t\t\tcase \"msg_followersonly\":\n\t\t\t\t\tcase \"msg_followersonly_followed\":\n\t\t\t\t\tcase \"msg_followersonly_zero\":\n\t\t\t\t\tcase \"msg_slowmode\":\n\t\t\t\t\tcase \"msg_suspended\":\n\t\t\t\t\tcase \"no_help\":\n\t\t\t\t\tcase \"usage_disconnect\":\n\t\t\t\t\tcase \"usage_help\":\n\t\t\t\t\tcase \"usage_me\":\n\t\t\t\t\tcase \"unavailable_command\":\n\t\t\t\t\t\tthis.log.info(basicLog);\n\t\t\t\t\t\tthis.emit(\"notice\", channel, msgid, msg);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Ignore this because we are already listening to HOSTTARGET..\n\t\t\t\t\tcase \"host_on\":\n\t\t\t\t\tcase \"host_off\":\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif(msg.includes(\"Login unsuccessful\") || msg.includes(\"Login authentication failed\")) {\n\t\t\t\t\t\t\tthis.wasCloseCalled = false;\n\t\t\t\t\t\t\tthis.reconnect = false;\n\t\t\t\t\t\t\tthis.reason = msg;\n\t\t\t\t\t\t\tthis.log.error(this.reason);\n\t\t\t\t\t\t\tthis.ws.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(msg.includes(\"Error logging in\") || msg.includes(\"Improperly formatted auth\")) {\n\t\t\t\t\t\t\tthis.wasCloseCalled = false;\n\t\t\t\t\t\t\tthis.reconnect = false;\n\t\t\t\t\t\t\tthis.reason = msg;\n\t\t\t\t\t\t\tthis.log.error(this.reason);\n\t\t\t\t\t\t\tthis.ws.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(msg.includes(\"Invalid NICK\")) {\n\t\t\t\t\t\t\tthis.wasCloseCalled = false;\n\t\t\t\t\t\t\tthis.reconnect = false;\n\t\t\t\t\t\t\tthis.reason = \"Invalid NICK.\";\n\t\t\t\t\t\t\tthis.log.error(this.reason);\n\t\t\t\t\t\t\tthis.ws.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.log.warn(`Could not parse NOTICE from tmi.twitch.tv:\\n${JSON.stringify(message, null, 4)}`);\n\t\t\t\t\t\t\tthis.emit(\"notice\", channel, msgid, msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Handle subanniversary / resub..\n\t\t\tcase \"USERNOTICE\":\n\t\t\t\tvar username = tags[\"display-name\"] || tags[\"login\"];\n\t\t\t\tvar plan = tags[\"msg-param-sub-plan\"] || \"\";\n\t\t\t\tvar planName = _.unescapeIRC(_.get(tags[\"msg-param-sub-plan-name\"], \"\")) || null;\n\t\t\t\tvar prime = plan.includes(\"Prime\");\n\t\t\t\tvar methods = { prime, plan, planName };\n\t\t\t\tvar streakMonths = ~~(tags[\"msg-param-streak-months\"] || 0);\n\t\t\t\tvar recipient = tags[\"msg-param-recipient-display-name\"] || tags[\"msg-param-recipient-user-name\"];\n\t\t\t\tvar giftSubCount = ~~tags[\"msg-param-mass-gift-count\"];\n\t\t\t\ttags[\"message-type\"] = msgid;\n\n\t\t\t\tswitch(msgid) {\n\t\t\t\t\t// Handle resub\n\t\t\t\t\tcase \"resub\":\n\t\t\t\t\t\tthis.emits([\"resub\", \"subanniversary\"], [\n\t\t\t\t\t\t\t[channel, username, streakMonths, msg, tags, methods]\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle sub\n\t\t\t\t\tcase \"sub\":\n\t\t\t\t\t\tthis.emit(\"subscription\", channel, username, methods, msg, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle gift sub\n\t\t\t\t\tcase \"subgift\":\n\t\t\t\t\t\tthis.emit(\"subgift\", channel, username, streakMonths, recipient, methods, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle anonymous gift sub\n\t\t\t\t\t// Need proof that this event occur\n\t\t\t\t\tcase \"anonsubgift\":\n\t\t\t\t\t\tthis.emit(\"anonsubgift\", channel, streakMonths, recipient, methods, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle random gift subs\n\t\t\t\t\tcase \"submysterygift\":\n\t\t\t\t\t\tthis.emit(\"submysterygift\", channel, username, giftSubCount, methods, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle anonymous random gift subs\n\t\t\t\t\t// Need proof that this event occur\n\t\t\t\t\tcase \"anonsubmysterygift\":\n\t\t\t\t\t\tthis.emit(\"anonsubmysterygift\", channel, giftSubCount, methods, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle user upgrading from Prime to a normal tier sub\n\t\t\t\t\tcase \"primepaidupgrade\":\n\t\t\t\t\t\tthis.emit(\"primepaidupgrade\", channel, username, methods, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle user upgrading from a gifted sub\n\t\t\t\t\tcase \"giftpaidupgrade\":\n\t\t\t\t\t\tvar sender = tags[\"msg-param-sender-name\"] || tags[\"msg-param-sender-login\"];\n\t\t\t\t\t\tthis.emit(\"giftpaidupgrade\", channel, username, sender, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle user upgrading from an anonymous gifted sub\n\t\t\t\t\tcase \"anongiftpaidupgrade\":\n\t\t\t\t\t\tthis.emit(\"anongiftpaidupgrade\", channel, username, tags);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Handle raid\n\t\t\t\t\tcase \"raid\":\n\t\t\t\t\t\tvar username = tags[\"msg-param-displayName\"] || tags[\"msg-param-login\"];\n\t\t\t\t\t\tvar viewers = +tags[\"msg-param-viewerCount\"];\n\t\t\t\t\t\tthis.emit(\"raided\", channel, username, viewers, tags);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// Handle ritual\n\t\t\t\t\tcase \"ritual\":\n\t\t\t\t\t\tvar ritualName = tags[\"msg-param-ritual-name\"];\n\t\t\t\t\t\tswitch(ritualName) {\n\t\t\t\t\t\t\t// Handle new chatter ritual\n\t\t\t\t\t\t\tcase \"new_chatter\":\n\t\t\t\t\t\t\t\tthis.emit(\"newchatter\", channel, username, tags, msg);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t// All unknown rituals should be passed through\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthis.emit(\"ritual\", ritualName, channel, username, tags, msg);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// All other msgid events should be emitted under a usernotice event\n\t\t\t\t\t// until it comes up and needs to be added..\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.emit(\"usernotice\", msgid, channel, tags, msg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t// Channel is now hosting another channel or exited host mode..\n\t\t\tcase \"HOSTTARGET\":\n\t\t\t\tvar msgSplit = msg.split(\" \");\n\t\t\t\tvar viewers = ~~msgSplit[1] || 0;\n\t\t\t\t// Stopped hosting..\n\t\t\t\tif(msgSplit[0] === \"-\") {\n\t\t\t\t\tthis.log.info(`[${channel}] Exited host mode.`);\n\t\t\t\t\tthis.emits([\"unhost\", \"_promiseUnhost\"], [[channel, viewers], [null]]);\n\t\t\t\t}\n\t\t\t\t// Now hosting..\n\t\t\t\telse {\n\t\t\t\t\tthis.log.info(`[${channel}] Now hosting ${msgSplit[0]} for ${viewers} viewer(s).`);\n\t\t\t\t\tthis.emit(\"hosting\", channel, msgSplit[0], viewers);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Someone has been timed out or chat has been cleared by a moderator..\n\t\t\tcase \"CLEARCHAT\":\n\t\t\t\t// User has been banned / timed out by a moderator..\n\t\t\t\tif(message.params.length > 1) {\n\t\t\t\t\t// Duration returns null if it's a ban, otherwise it's a timeout..\n\t\t\t\t\tvar duration = _.get(message.tags[\"ban-duration\"], null);\n\n\t\t\t\t\tif(_.isNull(duration)) {\n\t\t\t\t\t\tthis.log.info(`[${channel}] ${msg} has been banned.`);\n\t\t\t\t\t\tthis.emit(\"ban\", channel, msg, null, message.tags);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.log.info(`[${channel}] ${msg} has been timed out for ${duration} seconds.`);\n\t\t\t\t\t\tthis.emit(\"timeout\", channel, msg, null, ~~duration, message.tags);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Chat was cleared by a moderator..\n\t\t\t\telse {\n\t\t\t\t\tthis.log.info(`[${channel}] Chat was cleared by a moderator.`);\n\t\t\t\t\tthis.emits([\"clearchat\", \"_promiseClear\"], [[channel], [null]]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Someone's message has been deleted\n\t\t\tcase \"CLEARMSG\":\n\t\t\t\tif(message.params.length > 1) {\n\t\t\t\t\tvar deletedMessage = msg;\n\t\t\t\t\tvar username = tags[\"login\"];\n\t\t\t\t\ttags[\"message-type\"] = \"messagedeleted\";\n\n\t\t\t\t\tthis.log.info(`[${channel}] ${username}'s message has been deleted.`);\n\t\t\t\t\tthis.emit(\"messagedeleted\", channel, username, deletedMessage, tags);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Received a reconnection request from the server..\n\t\t\tcase \"RECONNECT\":\n\t\t\t\tthis.log.info(\"Received RECONNECT request from Twitch..\");\n\t\t\t\tthis.log.info(`Disconnecting and reconnecting in ${Math.round(this.reconnectTimer / 1000)} seconds..`);\n\t\t\t\tthis.disconnect().catch(err => this.log.error(err));\n\t\t\t\tsetTimeout(() => this.connect().catch(err => this.log.error(err)), this.reconnectTimer);\n\t\t\t\tbreak;\n\n\t\t\t// Received when joining a channel and every time you send a PRIVMSG to a channel.\n\t\t\tcase \"USERSTATE\":\n\t\t\t\tmessage.tags.username = this.username;\n\n\t\t\t\t// Add the client to the moderators of this room..\n\t\t\t\tif(message.tags[\"user-type\"] === \"mod\") {\n\t\t\t\t\tif(!this.moderators[channel]) {\n\t\t\t\t\t\tthis.moderators[channel] = [];\n\t\t\t\t\t}\n\t\t\t\t\tif(!this.moderators[channel].includes(this.username)) {\n\t\t\t\t\t\tthis.moderators[channel].push(this.username);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Logged in and username doesn't start with justinfan..\n\t\t\t\tif(!_.isJustinfan(this.getUsername()) && !this.userstate[channel]) {\n\t\t\t\t\tthis.userstate[channel] = tags;\n\t\t\t\t\tthis.lastJoined = channel;\n\t\t\t\t\tthis.channels.push(channel);\n\t\t\t\t\tthis.log.info(`Joined ${channel}`);\n\t\t\t\t\tthis.emit(\"join\", channel, _.username(this.getUsername()), true);\n\t\t\t\t}\n\n\t\t\t\t// Emote-sets has changed, update it..\n\t\t\t\tif(message.tags[\"emote-sets\"] !== this.emotes) {\n\t\t\t\t\tthis._updateEmoteset(message.tags[\"emote-sets\"]);\n\t\t\t\t}\n\n\t\t\t\tthis.userstate[channel] = tags;\n\t\t\t\tbreak;\n\n\t\t\t// Describe non-channel-specific state informations..\n\t\t\tcase \"GLOBALUSERSTATE\":\n\t\t\t\tthis.globaluserstate = tags;\n\n\t\t\t\t// Received emote-sets..\n\t\t\t\tif(typeof message.tags[\"emote-sets\"] !== \"undefined\") {\n\t\t\t\t\tthis._updateEmoteset(message.tags[\"emote-sets\"]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Received when joining a channel and every time one of the chat room settings, like slow mode, change.\n\t\t\t// The message on join contains all room settings.\n\t\t\tcase \"ROOMSTATE\":\n\t\t\t\t// We use this notice to know if we successfully joined a channel..\n\t\t\t\tif(_.channel(this.lastJoined) === channel) { this.emit(\"_promiseJoin\", null, channel); }\n\n\t\t\t\t// Provide the channel name in the tags before emitting it..\n\t\t\t\tmessage.tags.channel = channel;\n\t\t\t\tthis.emit(\"roomstate\", channel, message.tags);\n\n\t\t\t\tif(!message.tags.hasOwnProperty(\"subs-only\")) {\n\t\t\t\t\t// Handle slow mode here instead of the slow_on/off notice..\n\t\t\t\t\t// This room is now in slow mode. You may send messages every slow_duration seconds.\n\t\t\t\t\tif(message.tags.hasOwnProperty(\"slow\")) {\n\t\t\t\t\t\tif(typeof message.tags.slow === \"boolean\" && !message.tags.slow) {\n\t\t\t\t\t\t\tvar disabled = [channel, false, 0];\n\t\t\t\t\t\t\tthis.log.info(`[${channel}] This room is no longer in slow mode.`);\n\t\t\t\t\t\t\tthis.emits([\"slow\", \"slowmode\", \"_promiseSlowoff\"], [disabled, disabled, [null]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar seconds = ~~message.tags.slow;\n\t\t\t\t\t\t\tvar enabled = [channel, true, seconds];\n\t\t\t\t\t\t\tthis.log.info(`[${channel}] This room is now in slow mode.`);\n\t\t\t\t\t\t\tthis.emits([\"slow\", \"slowmode\", \"_promiseSlow\"], [enabled, enabled, [null]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle followers only mode here instead of the followers_on/off notice..\n\t\t\t\t\t// This room is now in follower-only mode.\n\t\t\t\t\t// This room is now in <duration> followers-only mode.\n\t\t\t\t\t// This room is no longer in followers-only mode.\n\t\t\t\t\t// duration is in minutes (string)\n\t\t\t\t\t// -1 when /followersoff (string)\n\t\t\t\t\t// false when /followers with no duration (boolean)\n\t\t\t\t\tif(message.tags.hasOwnProperty(\"followers-only\")) {\n\t\t\t\t\t\tif(message.tags[\"followers-only\"] === \"-1\") {\n\t\t\t\t\t\t\tvar disabled = [channel, false, 0];\n\t\t\t\t\t\t\tthis.log.info(`[${channel}] This room is no longer in followers-only mode.`);\n\t\t\t\t\t\t\tthis.emits([\"followersonly\", \"followersmode\", \"_promiseFollowersoff\"], [disabled, disabled, [null]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar minutes = ~~message.tags[\"followers-only\"];\n\t\t\t\t\t\t\tvar enabled = [channel, true, minutes];\n\t\t\t\t\t\t\tthis.log.info(`[${channel}] This room is now in follower-only mode.`);\n\t\t\t\t\t\t\tthis.emits([\"followersonly\", \"followersmode\", \"_promiseFollowers\"], [enabled, enabled, [null]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Wrong cluster..\n\t\t\tcase \"SERVERCHANGE\":\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.log.warn(`Could not parse message from tmi.twitch.tv:\\n${JSON.stringify(message, null, 4)}`);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Messages from jtv..\n\telse if(message.prefix === \"jtv\") {\n\t\tswitch(message.command) {\n\t\t\tcase \"MODE\":\n\t\t\t\tif(msg === \"+o\") {\n\t\t\t\t\t// Add username to the moderators..\n\t\t\t\t\tif(!this.moderators[channel]) {\n\t\t\t\t\t\tthis.moderators[channel] = [];\n\t\t\t\t\t}\n\t\t\t\t\tif(!this.moderators[channel].includes(message.params[2])) {\n\t\t\t\t\t\tthis.moderators[channel].push(message.params[2]);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.emit(\"mod\", channel, message.params[2]);\n\t\t\t\t}\n\t\t\t\telse if(msg === \"-o\") {\n\t\t\t\t\t// Remove username from the moderators..\n\t\t\t\t\tif(!this.moderators[channel]) {\n\t\t\t\t\t\tthis.moderators[channel] = [];\n\t\t\t\t\t}\n\t\t\t\t\tthis.moderators[channel].filter(value => value != message.params[2]);\n\n\t\t\t\t\tthis.emit(\"unmod\", channel, message.params[2]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.log.warn(`Could not parse message from jtv:\\n${JSON.stringify(message, null, 4)}`);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Anything else..\n\telse {\n\t\tswitch(message.command) {\n\t\t\tcase \"353\":\n\t\t\t\tthis.emit(\"names\", message.params[2], message.params[3].split(\" \"));\n\t\t\t\tbreak;\n\n\t\t\tcase \"366\":\n\t\t\t\tbreak;\n\n\t\t\t// Someone has joined the channel..\n\t\t\tcase \"JOIN\":\n\t\t\t\tvar nick = message.prefix.split(\"!\")[0];\n\t\t\t\t// Joined a channel as a justinfan (anonymous) user..\n\t\t\t\tif(_.isJustinfan(this.getUsername()) && this.username === nick) {\n\t\t\t\t\tthis.lastJoined = channel;\n\t\t\t\t\tthis.channels.push(channel);\n\t\t\t\t\tthis.log.info(`Joined ${channel}`);\n\t\t\t\t\tthis.emit(\"join\", channel, nick, true);\n\t\t\t\t}\n\n\t\t\t\t// Someone else joined the channel, just emit the join event..\n\t\t\t\tif(this.username !== nick) {\n\t\t\t\t\tthis.emit(\"join\", channel, nick, false);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Someone has left the channel..\n\t\t\tcase \"PART\":\n\t\t\t\tvar isSelf = false;\n\t\t\t\tvar nick = message.prefix.split(\"!\")[0];\n\t\t\t\t// Client left a channel..\n\t\t\t\tif(this.username === nick) {\n\t\t\t\t\tisSelf = true;\n\t\t\t\t\tif(this.userstate[channel]) { delete this.userstate[channel]; }\n\n\t\t\t\t\tvar index = this.channels.indexOf(channel);\n\t\t\t\t\tif(index !== -1) { this.channels.splice(index, 1); }\n\n\t\t\t\t\tvar index = this.opts.channels.indexOf(channel);\n\t\t\t\t\tif(index !== -1) { this.opts.channels.splice(index, 1); }\n\n\t\t\t\t\tthis.log.info(`Left ${channel}`);\n\t\t\t\t\tthis.emit(\"_promisePart\", null);\n\t\t\t\t}\n\n\t\t\t\t// Client or someone else left the channel, emit the part event..\n\t\t\t\tthis.emit(\"part\", channel, nick, isSelf);\n\t\t\t\tbreak;\n\n\t\t\t// Received a whisper..\n\t\t\tcase \"WHISPER\":\n\t\t\t\tvar nick = message.prefix.split(\"!\")[0];\n\t\t\t\tthis.log.info(`[WHISPER] <${nick}>: ${msg}`);\n\n\t\t\t\t// Update the tags to provide the username..\n\t\t\t\tif(!message.tags.hasOwnProperty(\"username\")) {\n\t\t\t\t\tmessage.tags.username = nick;\n\t\t\t\t}\n\t\t\t\tmessage.tags[\"message-type\"] = \"whisper\";\n\n\t\t\t\tvar from = _.channel(message.tags.username);\n\t\t\t\t// Emit for both, whisper and message..\n\t\t\t\tthis.emits([\"whisper\", \"message\"], [\n\t\t\t\t\t[from, message.tags, msg, false]\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\tcase \"PRIVMSG\":\n\t\t\t\t// Add username (lowercase) to the tags..\n\t\t\t\tmessage.tags.username = message.prefix.split(\"!\")[0];\n\n\t\t\t\t// Message from JTV..\n\t\t\t\tif(message.tags.username === \"jtv\") {\n\t\t\t\t\tvar name = _.username(msg.split(\" \")[0]);\n\t\t\t\t\tvar autohost = msg.includes(\"auto\");\n\t\t\t\t\t// Someone is hosting the channel and the message contains how many viewers..\n\t\t\t\t\tif(msg.includes(\"hosting you for\")) {\n\t\t\t\t\t\tvar count = _.extractNumber(msg);\n\n\t\t\t\t\t\tthis.emit(\"hosted\", channel, name, count, autohost);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some is hosting the channel, but no viewer(s) count provided in the message..\n\t\t\t\t\telse if(msg.includes(\"hosting you\")) {\n\t\t\t\t\t\tthis.emit(\"hosted\", channel, name, 0, autohost);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tvar messagesLogLevel = _.get(this.opts.options.messagesLogLevel, \"info\")\n\n\t\t\t\t\t// Message is an action (/me <message>)..\n\t\t\t\t\tvar actionMessage = _.actionMessage(msg);\n\t\t\t\t\tmessage.tags[\"message-type\"] = actionMessage ? \"action\" : \"chat\";\n\t\t\t\t\tmsg = actionMessage ? actionMessage[1] : msg;\n\t\t\t\t\t// Check for Bits prior to actions message\n\t\t\t\t\tif (message.tags.hasOwnProperty(\"bits\")) {\n\t\t\t\t\t\tthis.emit(\"cheer\", channel, message.tags, msg);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//Handle Channel Point Redemptions (Require's Text Input)\n\t\t\t\t\t\tif (message.tags.hasOwnProperty(\"msg-id\")) {\n\t\t\t\t\t\t\tif (message.tags[\"msg-id\"] === \"highlighted-message\") {\n\t\t\t\t\t\t\t\tvar rewardtype = message.tags[\"msg-id\"];\n\t\t\t\t\t\t\t\tthis.emit(\"redeem\", channel, message.tags.username, rewardtype, message.tags, msg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (message.tags[\"msg-id\"] === \"skip-subs-mode-message\") {\n\t\t\t\t\t\t\t\tvar rewardtype = message.tags[\"msg-id\"];\n\t\t\t\t\t\t\t\tthis.emit(\"redeem\", channel, message.tags.username, rewardtype, message.tags, msg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (message.tags.hasOwnProperty(\"custom-reward-id\")) {\n\t\t\t\t\t\t\tvar rewardtype = message.tags[\"custom-reward-id\"];\n\t\t\t\t\t\t\tthis.emit(\"redeem\", channel, message.tags.username, rewardtype, message.tags, msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(actionMessage) {\n\t\t\t\t\t\t\tthis.log[messagesLogLevel](`[${channel}] *<${message.tags.username}>: ${msg}`);\n\t\t\t\t\t\t\tthis.emits([\"action\", \"message\"], [\n\t\t\t\t\t\t\t\t[channel, message.tags, msg, false]\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Message is a regular chat message..\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.log[messagesLogLevel](`[${channel}] <${message.tags.username}>: ${msg}`);\n\t\t\t\t\t\t\tthis.emits([\"chat\", \"message\"], [\n\t\t\t\t\t\t\t\t[channel, message.tags, msg, false]\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.log.warn(`Could not parse message:\\n${JSON.stringify(message, null, 4)}`);\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\n// Connect to server..\nclient.prototype.connect = function connect() {\n\treturn new Promise((resolve, reject) => {\n\t\tthis.server = _.get(this.opts.connection.server, \"irc-ws.chat.twitch.tv\");\n\t\tthis.port = _.get(this.opts.connection.port, 80);\n\n\t\t// Override port if using a secure connection..\n\t\tif(this.secure) { this.port = 443; }\n\t\tif(this.port === 443) { this.secure = true; }\n\n\t\tthis.reconnectTimer = this.reconnectTimer * this.reconnectDecay;\n\t\tif(this.reconnectTimer >= this.maxReconnectInterval) {\n\t\t\tthis.reconnectTimer = this.maxReconnectInterval;\n\t\t}\n\n\t\t// Connect to server from configuration..\n\t\tthis._openConnection();\n\t\tthis.once(\"_promiseConnect\", err => {\n\t\t\tif(!err) { resolve([this.server, ~~this.port]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n};\n\n// Open a connection..\nclient.prototype._openConnection = function _openConnection() {\n\tthis.ws = new _WebSocket(`${this.secure ? \"wss\" : \"ws\"}://${this.server}:${this.port}/`, \"irc\");\n\n\tthis.ws.onmessage = this._onMessage.bind(this);\n\tthis.ws.onerror = this._onError.bind(this);\n\tthis.ws.onclose = this._onClose.bind(this);\n\tthis.ws.onopen = this._onOpen.bind(this);\n};\n\n// Called when the WebSocket connection's readyState changes to OPEN.\n// Indicates that the connection is ready to send and receive data..\nclient.prototype._onOpen = function _onOpen() {\n\tif(_.isNull(this.ws) || this.ws.readyState !== 1) {\n\t\treturn;\n\t}\n\n\t// Emitting \"connecting\" event..\n\tthis.log.info(`Connecting to ${this.server} on port ${this.port}..`);\n\tthis.emit(\"connecting\", this.server, ~~this.port);\n\n\tthis.username = _.get(this.opts.identity.username, _.justinfan());\n\tthis._getToken()\n\t\t.then(token => {\n\t\t\tconst password = _.password(token);\n\n\t\t\t// Emitting \"logon\" event..\n\t\t\tthis.log.info(\"Sending authentication to server..\");\n\t\t\tthis.emit(\"logon\");\n\n\t\t\t// Authentication..\n\t\t\tthis.ws.send(\"CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership\");\n\t\t\tif(password) {\n\t\t\t\tthis.ws.send(`PASS ${password}`);\n\t\t\t}\n\t\t\telse if(_.isJustinfan(this.username)) {\n\t\t\t\tthis.ws.send(\"PASS SCHMOOPIIE\");\n\t\t\t}\n\t\t\tthis.ws.send(`NICK ${this.username}`);\n\t\t})\n\t\t.catch(err => {\n\t\t\tthis.emits([\"_promiseConnect\", \"disconnected\"], [[err], [\"Could not get a token.\"]]);\n\t\t});\n};\n\n// Fetches a token from the option.\nclient.prototype._getToken = function _getPassword() {\n\tlet passwordOption = this.opts.identity.password;\n\tlet password;\n\tif(typeof passwordOption === \"function\") {\n\t\tpassword = passwordOption();\n\t\tif(password instanceof Promise) {\n\t\t\treturn password;\n\t\t}\n\t\treturn Promise.resolve(password);\n\t}\n\treturn Promise.resolve(passwordOption);\n};\n\n// Called when a message is received from the server..\nclient.prototype._onMessage = function _onMessage(event) {\n\tvar parts = event.data.split(\"\\r\\n\");\n\n\tparts.forEach(str => {\n\t\tif(!_.isNull(str)) { this.handleMessage(parse.msg(str)); }\n\t});\n};\n\n// Called when an error occurs..\nclient.prototype._onError = function _onError() {\n\tthis.moderators = {};\n\tthis.userstate = {};\n\tthis.globaluserstate = {};\n\n\t// Stop the internal ping timeout check interval..\n\tclearInterval(this.pingLoop);\n\tclearTimeout(this.pingTimeout);\n\n\tthis.reason = !_.isNull(this.ws) ? \"Unable to connect.\" : \"Connection closed.\";\n\n\tthis.emits([\"_promiseConnect\", \"disconnected\"], [[this.reason]]);\n\n\t// Reconnect to server..\n\tif(this.reconnect && this.reconnections === this.maxReconnectAttempts) {\n\t\tthis.emit(\"maxreconnect\");\n\t\tthis.log.error(\"Maximum reconnection attempts reached.\");\n\t}\n\tif(this.reconnect && !this.reconnecting && this.reconnections <= this.maxReconnectAttempts-1) {\n\t\tthis.reconnecting = true;\n\t\tthis.reconnections = this.reconnections+1;\n\t\tthis.log.error(`Reconnecting in ${Math.round(this.reconnectTimer / 1000)} seconds..`);\n\t\tthis.emit(\"reconnect\");\n\t\tsetTimeout(() => {\n\t\t\tthis.reconnecting = false;\n\t\t\tthis.connect().catch(err => this.log.error(err));\n\t\t}, this.reconnectTimer);\n\t}\n\n\tthis.ws = null;\n};\n\n// Called when the WebSocket connection's readyState changes to CLOSED..\nclient.prototype._onClose = function _onClose() {\n\tthis.moderators = {};\n\tthis.userstate = {};\n\tthis.globaluserstate = {};\n\n\t// Stop the internal ping timeout check interval..\n\tclearInterval(this.pingLoop);\n\tclearTimeout(this.pingTimeout);\n\n\t// User called .disconnect(), don't try to reconnect.\n\tif(this.wasCloseCalled) {\n\t\tthis.wasCloseCalled = false;\n\t\tthis.reason = \"Connection closed.\";\n\t\tthis.log.info(this.reason);\n\t\tthis.emits([\"_promiseConnect\", \"_promiseDisconnect\", \"disconnected\"], [[this.reason], [null], [this.reason]]);\n\t}\n\t// Got disconnected from server..\n\telse {\n\t\tthis.emits([\"_promiseConnect\", \"disconnected\"], [[this.reason]]);\n\n\t\t// Reconnect to server..\n\t\tif(this.reconnect && this.reconnections === this.maxReconnectAttempts) {\n\t\t\tthis.emit(\"maxreconnect\");\n\t\t\tthis.log.error(\"Maximum reconnection attempts reached.\");\n\t\t}\n\t\tif(this.reconnect && !this.reconnecting && this.reconnections <= this.maxReconnectAttempts-1) {\n\t\t\tthis.reconnecting = true;\n\t\t\tthis.reconnections = this.reconnections+1;\n\t\t\tthis.log.error(`Could not connect to server. Reconnecting in ${Math.round(this.reconnectTimer / 1000)} seconds..`);\n\t\t\tthis.emit(\"reconnect\");\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.reconnecting = false;\n\t\t\t\tthis.connect().catch(err => this.log.error(err));\n\t\t\t}, this.reconnectTimer);\n\t\t}\n\t}\n\n\tthis.ws = null;\n};\n\n// Minimum of 600ms for command promises, if current latency exceeds, add 100ms to it to make sure it doesn't get timed out..\nclient.prototype._getPromiseDelay = function _getPromiseDelay() {\n\tif(this.currentLatency <= 600) { return 600; }\n\telse { return this.currentLatency + 100; }\n};\n\n// Send command to server or channel..\nclient.prototype._sendCommand = function _sendCommand(delay, channel, command, fn) {\n\t// Race promise against delay..\n\treturn new Promise((resolve, reject) => {\n\t\t// Make sure the socket is opened..\n\t\tif(_.isNull(this.ws) || this.ws.readyState !== 1) {\n\t\t\t// Disconnected from server..\n\t\t\treturn reject(\"Not connected to server.\");\n\t\t}\n\t\telse if(typeof delay === \"number\") {\n\t\t\t_.promiseDelay(delay).then(() => reject(\"No response from Twitch.\"));\n\t\t}\n\n\t\t// Executing a command on a channel..\n\t\tif(!_.isNull(channel)) {\n\t\t\tvar chan = _.channel(channel);\n\t\t\tthis.log.info(`[${chan}] Executing command: ${command}`);\n\t\t\tthis.ws.send(`PRIVMSG ${chan} :${command}`);\n\t\t}\n\n\t\t// Executing a raw command..\n\t\telse {\n\t\t\tthis.log.info(`Executing command: ${command}`);\n\t\t\tthis.ws.send(command);\n\t\t}\n\t\tif(typeof fn === 'function') {\n\t\t\tfn(resolve, reject);\n\t\t}\n\t\telse {\n\t\t\tresolve();\n\t\t}\n\t});\n};\n\n// Send a message to channel..\nclient.prototype._sendMessage = function _sendMessage(delay, channel, message, fn) {\n\t// Promise a result..\n\treturn new Promise((resolve, reject) => {\n\t\t// Make sure the socket is opened and not logged in as a justinfan user..\n\t\tif(_.isNull(this.ws) || this.ws.readyState !== 1) {\n\t\t\treturn reject(\"Not connected to server.\");\n\t\t}\n\t\telse if(_.isJustinfan(this.getUsername())) {\n\t\t\treturn reject(\"Cannot send anonymous messages.\");\n\t\t}\n\t\tvar chan = _.channel(channel);\n\t\tif(!this.userstate[chan]) { this.userstate[chan] = {} }\n\n\t\t// Split long lines otherwise they will be eaten by the server..\n\t\tif(message.length >= 500) {\n\t\t\tvar msg = _.splitLine(message, 500);\n\t\t\tmessage = msg[0];\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._sendMessage(delay, channel, msg[1], () => {});\n\t\t\t}, 350);\n\t\t}\n\n\t\tthis.ws.send(`PRIVMSG ${chan} :${message}`);\n\n\t\tvar emotes = {};\n\n\t\t// Parse regex and string emotes..\n\t\tObject.keys(this.emotesets).forEach(id =>\n\t\t\tthis.emotesets[id].forEach(emote => {\n\t\t\t\tvar emoteFunc = _.isRegex(emote.code) ? parse.emoteRegex : parse.emoteString;\n\t\t\t\treturn emoteFunc(message, emote.code, emote.id, emotes)\n\t\t\t})\n\t\t);\n\n\t\t// Merge userstate with parsed emotes..\n\t\tvar userstate = _.merge(\n\t\t\tthis.userstate[chan],\n\t\t\tparse.emotes({ emotes: parse.transformEmotes(emotes) || null })\n\t\t);\n\n\t\tvar messagesLogLevel = _.get(this.opts.options.messagesLogLevel, \"info\")\n\n\t\t// Message is an action (/me <message>)..\n\t\tvar actionMessage = _.actionMessage(message);\n\t\tif(actionMessage) {\n\t\t\tuserstate[\"message-type\"] = \"action\";\n\t\t\tthis.log[messagesLogLevel](`[${chan}] *<${this.getUsername()}>: ${actionMessage[1]}`);\n\t\t\tthis.emits([\"action\", \"message\"], [\n\t\t\t\t[chan, userstate, actionMessage[1], true]\n\t\t\t]);\n\t\t}\n\n\t\t// Message is a regular chat message..\n\t\telse {\n\t\t\tuserstate[\"message-type\"] = \"chat\";\n\t\t\tthis.log[messagesLogLevel](`[${chan}] <${this.getUsername()}>: ${message}`);\n\t\t\tthis.emits([\"chat\", \"message\"], [\n\t\t\t\t[chan, userstate, message, true]\n\t\t\t]);\n\t\t}\n\t\tif(typeof fn === 'function') {\n\t\t\tfn(resolve, reject);\n\t\t}\n\t\telse {\n\t\t\tresolve();\n\t\t}\n\t});\n};\n\n// Grab the emote-sets object from the API..\nclient.prototype._updateEmoteset = function _updateEmoteset(sets) {\n\tthis.emotes = sets;\n\n\tthis._getToken()\n\t.then(token =>\n\t\tthis.api({\n\t\t\turl: `/chat/emoticon_images?emotesets=${sets}`,\n\t\t\theaders: {\n\t\t\t\t\"Accept\": \"application/vnd.twitchtv.v5+json\",\n\t\t\t\t\"Authorization\": `OAuth ${_.token(token)}`,\n\t\t\t\t\"Client-ID\": this.clientId\n\t\t\t}\n\t\t}, (err, res, body) => {\n\t\t\tif(!err) {\n\t\t\t\tthis.emotesets = body[\"emoticon_sets\"] || {};\n\t\t\t\treturn this.emit(\"emotesets\", sets, this.emotesets);\n\t\t\t}\n\t\t\tsetTimeout(() => this._updateEmoteset(sets), 60000);\n\t\t})\n\t)\n\t.catch(() => setTimeout(() => this._updateEmoteset(sets), 60000));\n};\n\n// Get current username..\nclient.prototype.getUsername = function getUsername() {\n\treturn this.username;\n};\n\n// Get current options..\nclient.prototype.getOptions = function getOptions() {\n\treturn this.opts;\n};\n\n// Get current channels..\nclient.prototype.getChannels = function getChannels() {\n\treturn this.channels;\n};\n\n// Check if username is a moderator on a channel..\nclient.prototype.isMod = function isMod(channel, username) {\n\tvar chan = _.channel(channel);\n\tif(!this.moderators[chan]) { this.moderators[chan] = []; }\n\treturn this.moderators[chan].includes(_.username(username));\n};\n\n// Get readyState..\nclient.prototype.readyState = function readyState() {\n\tif(_.isNull(this.ws)) { return \"CLOSED\"; }\n\treturn [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"][this.ws.readyState];\n};\n\n// Determine if the client has a WebSocket and it's open..\nclient.prototype._isConnected = function _isConnected() {\n\t\n\treturn this.ws !== null && this.ws.readyState === 1;\n}\n\n// Disconnect from server..\nclient.prototype.disconnect = function disconnect() {\n\treturn new Promise((resolve, reject) => {\n\t\tif(!_.isNull(this.ws) && this.ws.readyState !== 3) {\n\t\t\tthis.wasCloseCalled = true;\n\t\t\tthis.log.info(\"Disconnecting from server..\");\n\t\t\tthis.ws.close();\n\t\t\tthis.once(\"_promiseDisconnect\", () => resolve([this.server, ~~this.port]));\n\t\t}\n\t\telse {\n\t\t\tthis.log.error(\"Cannot disconnect from server. Socket is not opened or connection is already closing.\");\n\t\t\treject(\"Cannot disconnect from server. Socket is not opened or connection is already closing.\");\n\t\t}\n\t});\n};\n\n// Expose everything, for browser and Node..\nif( true && module.exports) {\n\tmodule.exports = client;\n}\nif(typeof window !== \"undefined\") {\n\twindow.tmi = {};\n\twindow.tmi.client = client;\n\twindow.tmi.Client = client;\n}\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/client.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/commands.js":
/*!*********************************************!*\
  !*** ./node_modules/tmi.js/lib/commands.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _ = __webpack_require__(/*! ./utils */ \"./node_modules/tmi.js/lib/utils.js\");\n\n// Enable followers-only mode on a channel..\nfunction followersonly(channel, minutes) {\n\tchannel = _.channel(channel);\n\tminutes = _.get(minutes, 30);\n\n\t// Send the command to the server and race the Promise against a delay..\n\treturn this._sendCommand(this._getPromiseDelay(), channel, `/followers ${minutes}`, (resolve, reject) => {\n\t\t// Received _promiseFollowers event, resolve or reject..\n\t\tthis.once(\"_promiseFollowers\", err => {\n\t\t\tif(!err) { resolve([channel, ~~minutes]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n}\n\n// Disable followers-only mode on a channel..\nfunction followersonlyoff(channel) {\n\tchannel = _.channel(channel);\n\n\t// Send the command to the server and race the Promise against a delay..\n\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/followersoff\", (resolve, reject) => {\n\t\t// Received _promiseFollowersoff event, resolve or reject..\n\t\tthis.once(\"_promiseFollowersoff\", err => {\n\t\t\tif(!err) { resolve([channel]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n}\n\n// Leave a channel..\nfunction part(channel) {\n\tchannel = _.channel(channel);\n\n\t// Send the command to the server and race the Promise against a delay..\n\treturn this._sendCommand(this._getPromiseDelay(), null, `PART ${channel}`, (resolve, reject) => {\n\t\t// Received _promisePart event, resolve or reject..\n\t\tthis.once(\"_promisePart\", err => {\n\t\t\tif(!err) { resolve([channel]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n}\n\n// Enable R9KBeta mode on a channel..\nfunction r9kbeta(channel) {\n\tchannel = _.channel(channel);\n\n\t// Send the command to the server and race the Promise against a delay..\n\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/r9kbeta\", (resolve, reject) => {\n\t\t// Received _promiseR9kbeta event, resolve or reject..\n\t\tthis.once(\"_promiseR9kbeta\", err => {\n\t\t\tif(!err) { resolve([channel]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n}\n\n// Disable R9KBeta mode on a channel..\nfunction r9kbetaoff(channel) {\n\tchannel = _.channel(channel);\n\n\t// Send the command to the server and race the Promise against a delay..\n\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/r9kbetaoff\", (resolve, reject) => {\n\t\t// Received _promiseR9kbetaoff event, resolve or reject..\n\t\tthis.once(\"_promiseR9kbetaoff\", err => {\n\t\t\tif(!err) { resolve([channel]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n}\n\n// Enable slow mode on a channel..\nfunction slow(channel, seconds) {\n\tchannel = _.channel(channel);\n\tseconds = _.get(seconds, 300);\n\n\t// Send the command to the server and race the Promise against a delay..\n\treturn this._sendCommand(this._getPromiseDelay(), channel, `/slow ${seconds}`, (resolve, reject) => {\n\t\t// Received _promiseSlow event, resolve or reject..\n\t\tthis.once(\"_promiseSlow\", err => {\n\t\t\tif(!err) { resolve([channel, ~~seconds]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n}\n\n// Disable slow mode on a channel..\nfunction slowoff(channel) {\n\tchannel = _.channel(channel);\n\n\t// Send the command to the server and race the Promise against a delay..\n\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/slowoff\", (resolve, reject) => {\n\t\t// Received _promiseSlowoff event, resolve or reject..\n\t\tthis.once(\"_promiseSlowoff\", err => {\n\t\t\tif(!err) { resolve([channel]); }\n\t\t\telse { reject(err); }\n\t\t});\n\t});\n}\n\nmodule.exports = {\n\t// Send action message (/me <message>) on a channel..\n\taction(channel, message) {\n\t\tchannel = _.channel(channel);\n\t\tmessage = `\\u0001ACTION ${message}\\u0001`;\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendMessage(this._getPromiseDelay(), channel, message, (resolve, reject) => {\n\t\t\t// At this time, there is no possible way to detect if a message has been sent has been eaten\n\t\t\t// by the server, so we can only resolve the Promise.\n\t\t\tresolve([channel, message]);\n\t\t});\n\t},\n\n\t// Ban username on channel..\n\tban(channel, username, reason) {\n\t\tchannel = _.channel(channel);\n\t\tusername = _.username(username);\n\t\treason = _.get(reason, \"\");\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/ban ${username} ${reason}`, (resolve, reject) => {\n\t\t\t// Received _promiseBan event, resolve or reject..\n\t\t\tthis.once(\"_promiseBan\", err => {\n\t\t\t\tif(!err) { resolve([channel, username, reason]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Clear all messages on a channel..\n\tclear(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/clear\", (resolve, reject) => {\n\t\t\t// Received _promiseClear event, resolve or reject..\n\t\t\tthis.once(\"_promiseClear\", err => {\n\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Change the color of your username..\n\tcolor(channel, newColor) {\n\t\tnewColor = _.get(newColor, channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), \"#tmijs\", `/color ${newColor}`, (resolve, reject) => {\n\t\t\t// Received _promiseColor event, resolve or reject..\n\t\t\tthis.once(\"_promiseColor\", err => {\n\t\t\t\tif(!err) { resolve([newColor]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Run commercial on a channel for X seconds..\n\tcommercial(channel, seconds) {\n\t\tchannel = _.channel(channel);\n\t\tseconds = _.get(seconds, 30);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/commercial ${seconds}`, (resolve, reject) => {\n\t\t\t// Received _promiseCommercial event, resolve or reject..\n\t\t\tthis.once(\"_promiseCommercial\", err => {\n\t\t\t\tif(!err) { resolve([channel, ~~seconds]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\t\n\t// Delete a specific message on a channel\n\tdeletemessage(channel, messageUUID) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/delete ${messageUUID}`, (resolve, reject) => {\n\t\t\t// Received _promiseDeletemessage event, resolve or reject..\n\t\t\tthis.once(\"_promiseDeletemessage\", err => {\n\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Enable emote-only mode on a channel..\n\temoteonly(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/emoteonly\", (resolve, reject) => {\n\t\t\t// Received _promiseEmoteonly event, resolve or reject..\n\t\t\tthis.once(\"_promiseEmoteonly\", err => {\n\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Disable emote-only mode on a channel..\n\temoteonlyoff(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/emoteonlyoff\", (resolve, reject) => {\n\t\t\t// Received _promiseEmoteonlyoff event, resolve or reject..\n\t\t\tthis.once(\"_promiseEmoteonlyoff\", err => {\n\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Enable followers-only mode on a channel..\n\tfollowersonly: followersonly,\n\n\t// Alias for followersonly()..\n\tfollowersmode: followersonly,\n\n\t// Disable followers-only mode on a channel..\n\tfollowersonlyoff: followersonlyoff,\n\n\t// Alias for followersonlyoff()..\n\tfollowersmodeoff: followersonlyoff,\n\n\t// Host a channel..\n\thost(channel, target) {\n\t\tchannel = _.channel(channel);\n\t\ttarget = _.username(target);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(2000, channel, `/host ${target}`, (resolve, reject) => {\n\t\t\t// Received _promiseHost event, resolve or reject..\n\t\t\tthis.once(\"_promiseHost\", (err, remaining) => {\n\t\t\t\tif(!err) { resolve([channel, target, ~~remaining]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Join a channel..\n\tjoin(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server ..\n\t\treturn this._sendCommand(null, null, `JOIN ${channel}`, (resolve, reject) => {\n\t\t\tvar eventName = \"_promiseJoin\";\n\t\t\tvar hasFulfilled = false;\n\t\t\tvar listener = (err, joinedChannel) => {\n\t\t\t\tif(channel === _.channel(joinedChannel)) {\n\t\t\t\t\t// Received _promiseJoin event for the target channel, resolve or reject..\n\t\t\t\t\tthis.removeListener(eventName, listener);\n\t\t\t\t\thasFulfilled = true;\n\t\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\t\telse { reject(err); }\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.on(eventName, listener);\n\t\t\t// Race the Promise against a delay..\n\t\t\tvar delay = this._getPromiseDelay();\n\t\t\t_.promiseDelay(delay).then(() => {\n\t\t\t\tif(!hasFulfilled) {\n\t\t\t\t\tthis.emit(eventName, \"No response from Twitch.\", channel);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t// Mod username on channel..\n\tmod(channel, username) {\n\t\tchannel = _.channel(channel);\n\t\tusername = _.username(username);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/mod ${username}`, (resolve, reject) => {\n\t\t\t// Received _promiseMod event, resolve or reject..\n\t\t\tthis.once(\"_promiseMod\", err => {\n\t\t\t\tif(!err) { resolve([channel, username]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Get list of mods on a channel..\n\tmods(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/mods\", (resolve, reject) => {\n\t\t\t// Received _promiseMods event, resolve or reject..\n\t\t\tthis.once(\"_promiseMods\", (err, mods) => {\n\t\t\t\tif(!err) {\n\t\t\t\t\t// Update the internal list of moderators..\n\t\t\t\t\tmods.forEach(username => {\n\t\t\t\t\t\tif(!this.moderators[channel]) { this.moderators[channel] = []; }\n\t\t\t\t\t\tif(!this.moderators[channel].includes(username)) { this.moderators[channel].push(username); }\n\t\t\t\t\t});\n\t\t\t\t\tresolve(mods);\n\t\t\t\t}\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Leave a channel..\n\tpart: part,\n\n\t// Alias for part()..\n\tleave: part,\n\n\t// Send a ping to the server..\n\tping() {\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), null, \"PING\", (resolve, reject) => {\n\t\t\t// Update the internal ping timeout check interval..\n\t\t\tthis.latency = new Date();\n\t\t\tthis.pingTimeout = setTimeout(() => {\n\t\t\t\tif(this.ws !== null) {\n\t\t\t\t\tthis.wasCloseCalled = false;\n\t\t\t\t\tthis.log.error(\"Ping timeout.\");\n\t\t\t\t\tthis.ws.close();\n\n\t\t\t\t\tclearInterval(this.pingLoop);\n\t\t\t\t\tclearTimeout(this.pingTimeout);\n\t\t\t\t}\n\t\t\t}, _.get(this.opts.connection.timeout, 9999));\n\n\t\t\t// Received _promisePing event, resolve or reject..\n\t\t\tthis.once(\"_promisePing\", latency => resolve([parseFloat(latency)]));\n\t\t});\n\t},\n\n\t// Enable R9KBeta mode on a channel..\n\tr9kbeta: r9kbeta,\n\n\t// Alias for r9kbeta()..\n\tr9kmode: r9kbeta,\n\n\t// Disable R9KBeta mode on a channel..\n\tr9kbetaoff: r9kbetaoff,\n\n\t// Alias for r9kbetaoff()..\n\tr9kmodeoff: r9kbetaoff,\n\n\t// Send a raw message to the server..\n\traw(message) {\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), null, message, (resolve, reject) => {\n\t\t\tresolve([message]);\n\t\t});\n\t},\n\n\t// Send a message on a channel..\n\tsay(channel, message) {\n\t\tchannel = _.channel(channel);\n\n\t\tif((message.startsWith(\".\") && !message.startsWith(\"..\")) || message.startsWith(\"/\") || message.startsWith(\"\\\\\")) {\n\t\t\t// Check if the message is an action message..\n\t\t\tif(message.substr(1, 3) === \"me \") {\n\t\t\t\treturn this.action(channel, message.substr(4));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Send the command to the server and race the Promise against a delay..\n\t\t\t\treturn this._sendCommand(this._getPromiseDelay(), channel, message, (resolve, reject) => {\n\t\t\t\t\t// At this time, there is no possible way to detect if a message has been sent has been eaten\n\t\t\t\t\t// by the server, so we can only resolve the Promise.\n\t\t\t\t\tresolve([channel, message]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendMessage(this._getPromiseDelay(), channel, message, (resolve, reject) => {\n\t\t\t// At this time, there is no possible way to detect if a message has been sent has been eaten\n\t\t\t// by the server, so we can only resolve the Promise.\n\t\t\tresolve([channel, message]);\n\t\t});\n\t},\n\n\t// Enable slow mode on a channel..\n\tslow: slow,\n\n\t// Alias for slow()..\n\tslowmode: slow,\n\n\t// Disable slow mode on a channel..\n\tslowoff: slowoff,\n\n\t// Alias for slowoff()..\n\tslowmodeoff: slowoff,\n\n\t// Enable subscribers mode on a channel..\n\tsubscribers(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/subscribers\", (resolve, reject) => {\n\t\t\t// Received _promiseSubscribers event, resolve or reject..\n\t\t\tthis.once(\"_promiseSubscribers\", err => {\n\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Disable subscribers mode on a channel..\n\tsubscribersoff(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/subscribersoff\", (resolve, reject) => {\n\t\t\t// Received _promiseSubscribersoff event, resolve or reject..\n\t\t\tthis.once(\"_promiseSubscribersoff\", err => {\n\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Timeout username on channel for X seconds..\n\ttimeout(channel, username, seconds, reason) {\n\t\tchannel = _.channel(channel);\n\t\tusername = _.username(username);\n\n\t\tif(!_.isNull(seconds) && !_.isInteger(seconds)) {\n\t\t\treason = seconds;\n\t\t\tseconds = 300;\n\t\t}\n\n\t\tseconds = _.get(seconds, 300);\n\t\treason = _.get(reason, \"\");\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/timeout ${username} ${seconds} ${reason}`, (resolve, reject) => {\n\t\t\t// Received _promiseTimeout event, resolve or reject..\n\t\t\tthis.once(\"_promiseTimeout\", err => {\n\t\t\t\tif(!err) { resolve([channel, username, ~~seconds, reason]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Unban username on channel..\n\tunban(channel, username) {\n\t\tchannel = _.channel(channel);\n\t\tusername = _.username(username);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/unban ${username}`, (resolve, reject) => {\n\t\t\t// Received _promiseUnban event, resolve or reject..\n\t\t\tthis.once(\"_promiseUnban\", err => {\n\t\t\t\tif(!err) { resolve([channel, username]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// End the current hosting..\n\tunhost(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(2000, channel, \"/unhost\", (resolve, reject) => {\n\t\t\t// Received _promiseUnhost event, resolve or reject..\n\t\t\tthis.once(\"_promiseUnhost\", err => {\n\t\t\t\tif(!err) { resolve([channel]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Unmod username on channel..\n\tunmod(channel, username) {\n\t\tchannel = _.channel(channel);\n\t\tusername = _.username(username);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/unmod ${username}`, (resolve, reject) => {\n\t\t\t// Received _promiseUnmod event, resolve or reject..\n\t\t\tthis.once(\"_promiseUnmod\", err => {\n\t\t\t\tif(!err) { resolve([channel, username]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Unvip username on channel..\n\tunvip(channel, username) {\n\t\tchannel = _.channel(channel);\n\t\tusername = _.username(username);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/unvip ${username}`, (resolve, reject) => {\n\t\t\t// Received _promiseUnvip event, resolve or reject..\n\t\t\tthis.once(\"_promiseUnvip\", err => {\n\t\t\t\tif(!err) { resolve([channel, username]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Add username to VIP list on channel..\n\tvip(channel, username) {\n\t\tchannel = _.channel(channel);\n\t\tusername = _.username(username);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, `/vip ${username}`, (resolve, reject) => {\n\t\t\t// Received _promiseVip event, resolve or reject..\n\t\t\tthis.once(\"_promiseVip\", err => {\n\t\t\t\tif(!err) { resolve([channel, username]); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Get list of VIPs on a channel..\n\tvips(channel) {\n\t\tchannel = _.channel(channel);\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), channel, \"/vips\", (resolve, reject) => {\n\t\t\t// Received _promiseVips event, resolve or reject..\n\t\t\tthis.once(\"_promiseVips\", (err, vips) => {\n\t\t\t\tif(!err) { resolve(vips); }\n\t\t\t\telse { reject(err); }\n\t\t\t});\n\t\t});\n\t},\n\n\t// Send an whisper message to a user..\n\twhisper(username, message) {\n\t\tusername = _.username(username);\n\n\t\t// The server will not send a whisper to the account that sent it.\n\t\tif(username === this.getUsername()) {\n\t\t\treturn Promise.reject(\"Cannot send a whisper to the same account.\");\n\t\t}\n\n\t\t// Send the command to the server and race the Promise against a delay..\n\t\treturn this._sendCommand(this._getPromiseDelay(), \"#tmijs\", `/w ${username} ${message}`, (resolve, reject) => {\n\t\t\tthis.once(\"_promiseWhisper\", (err) => {\n\t\t\t\tif (err) { reject(err); }\n\t\t\t});\n\t\t}).catch((err) => {\n\t\t\t// Either an \"actual\" error occured or the timeout triggered\n\t\t\t// the latter means no errors have occured and we can resolve\n\t\t\t// else just elevate the error\n\t\t\tif(err && typeof err === 'string' && err.indexOf(\"No response from Twitch.\") !== 0) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tvar from = _.channel(username),\n\t\t\t\tuserstate = _.merge({\n\t\t\t\t\t\t\"message-type\": \"whisper\",\n\t\t\t\t\t\t\"message-id\": null,\n\t\t\t\t\t\t\"thread-id\": null,\n\t\t\t\t\t\tusername: this.getUsername()\n\t\t\t\t\t}, this.globaluserstate);\n\n\t\t\t// Emit for both, whisper and message..\n\t\t\tthis.emits([\"whisper\", \"message\"], [\n\t\t\t\t[from, userstate, message, true],\n\t\t\t\t[from, userstate, message, true]\n\t\t\t]);\n\t\t\treturn [username, message];\n\t\t});\n\t}\n}\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/commands.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/events.js":
/*!*******************************************!*\
  !*** ./node_modules/tmi.js/lib/events.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/*\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nfunction EventEmitter() {\n\tthis._events = this._events || {};\n\tthis._maxListeners = this._maxListeners || undefined;\n}\n\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n\tif (!isNumber(n) || n < 0 || isNaN(n)) {\n\t\tthrow TypeError(\"n must be a positive number\");\n\t}\n\n\tthis._maxListeners = n;\n\n\treturn this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n\tvar er, handler, len, args, i, listeners;\n\n\tif (!this._events) { this._events = {}; }\n\n\t// If there is no 'error' event listener then throw.\n\tif (type === \"error\") {\n\t\tif (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {\n\t\t\ter = arguments[1];\n\t\t\tif (er instanceof Error) { throw er; }\n\t\t\tthrow TypeError(\"Uncaught, unspecified \\\"error\\\" event.\");\n\t\t}\n\t}\n\n\thandler = this._events[type];\n\n\tif (isUndefined(handler)) { return false; }\n\n\tif (isFunction(handler)) {\n\t\tswitch (arguments.length) {\n\t\t\t// fast cases\n\t\t\tcase 1:\n\t\t\t\thandler.call(this);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\thandler.call(this, arguments[1]);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\thandler.call(this, arguments[1], arguments[2]);\n\t\t\t\tbreak;\n\t\t\t\t// slower\n\t\t\tdefault:\n\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t\thandler.apply(this, args);\n\t\t}\n\t} else if (isObject(handler)) {\n\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\tlisteners = handler.slice();\n\t\tlen = listeners.length;\n\t\tfor (i = 0; i < len; i++) { listeners[i].apply(this, args); }\n\t}\n\n\treturn true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n\tvar m;\n\n\tif (!isFunction(listener)) { throw TypeError(\"listener must be a function\"); }\n\n\tif (!this._events) { this._events = {}; }\n\n\t// To avoid recursion in the case that type === \"newListener\"! Before\n\t// adding it to the listeners, first emit \"newListener\".\n\tif (this._events.newListener) {\n\t\tthis.emit(\"newListener\", type, isFunction(listener.listener) ? listener.listener : listener);\n\t}\n\n\t// Optimize the case of one listener. Don't need the extra array object.\n\tif (!this._events[type]) { this._events[type] = listener; }\n\t// If we've already got an array, just append.\n\telse if (isObject(this._events[type])) { this._events[type].push(listener); }\n\t// Adding the second element, need to change to array.\n\telse { this._events[type] = [this._events[type], listener]; }\n\n\t// Check for listener leak\n\tif (isObject(this._events[type]) && !this._events[type].warned) {\n\t\tif (!isUndefined(this._maxListeners)) {\n\t\t\tm = this._maxListeners;\n\t\t} else {\n\t\t\tm = EventEmitter.defaultMaxListeners;\n\t\t}\n\n\t\tif (m && m > 0 && this._events[type].length > m) {\n\t\t\tthis._events[type].warned = true;\n\t\t\tconsole.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\", this._events[type].length);\n\t\t\t// Not supported in IE 10\n\t\t\tif (typeof console.trace === \"function\") {\n\t\t\t\tconsole.trace();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n// Modified to support multiple calls..\nEventEmitter.prototype.once = function(type, listener) {\n\tif (!isFunction(listener)) { throw TypeError(\"listener must be a function\"); }\n\n\tvar fired = false;\n\n\tif (this._events.hasOwnProperty(type) && type.charAt(0) === \"_\") {\n\t\tvar count = 1;\n\t\tvar searchFor = type;\n\n\t\tfor (var k in this._events){\n\t\t\tif (this._events.hasOwnProperty(k) && k.startsWith(searchFor)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\ttype = type + count;\n\t}\n\n\tfunction g() {\n\t\tif (type.charAt(0) === \"_\" && !isNaN(type.substr(type.length - 1))) {\n\t\t\ttype = type.substring(0, type.length - 1);\n\t\t}\n\t\tthis.removeListener(type, g);\n\n\t\tif (!fired) {\n\t\t\tfired = true;\n\t\t\tlistener.apply(this, arguments);\n\t\t}\n\t}\n\n\tg.listener = listener;\n\tthis.on(type, g);\n\n\treturn this;\n};\n\n// Emits a \"removeListener\" event if the listener was removed..\n// Modified to support multiple calls from .once()..\nEventEmitter.prototype.removeListener = function(type, listener) {\n\tvar list, position, length, i;\n\n\tif (!isFunction(listener)) { throw TypeError(\"listener must be a function\"); }\n\n\tif (!this._events || !this._events[type]) { return this; }\n\n\tlist = this._events[type];\n\tlength = list.length;\n\tposition = -1;\n\tif (list === listener || (isFunction(list.listener) && list.listener === listener)) {\n\t\tdelete this._events[type];\n\n\t\tif (this._events.hasOwnProperty(type + \"2\") && type.charAt(0) === \"_\") {\n\t\t\tvar searchFor = type;\n\t\t\tfor (var k in this._events){\n\t\t\t\tif (this._events.hasOwnProperty(k) && k.startsWith(searchFor)) {\n\t\t\t\t\tif (!isNaN(parseInt(k.substr(k.length - 1)))) {\n\t\t\t\t\t\tthis._events[type + parseInt(k.substr(k.length - 1) - 1)] = this._events[k];\n\t\t\t\t\t\tdelete this._events[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._events[type] = this._events[type + \"1\"];\n\t\t\tdelete this._events[type + \"1\"];\n\t\t}\n\t\tif (this._events.removeListener) { this.emit(\"removeListener\", type, listener); }\n\t}\n\telse if (isObject(list)) {\n\t\tfor (i = length; i-- > 0;) {\n\t\t\tif (list[i] === listener ||\n\t\t\t\t(list[i].listener && list[i].listener === listener)) {\n\t\t\t\tposition = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (position < 0) { return this; }\n\n\t\tif (list.length === 1) {\n\t\t\tlist.length = 0;\n\t\t\tdelete this._events[type];\n\t\t}\n\t\telse { list.splice(position, 1); }\n\n\t\tif (this._events.removeListener) { this.emit(\"removeListener\", type, listener); }\n\t}\n\n\treturn this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n\tvar key, listeners;\n\n\tif (!this._events) { return this; }\n\n\t// not listening for removeListener, no need to emit\n\tif (!this._events.removeListener) {\n\t\tif (arguments.length === 0) { this._events = {}; }\n\t\telse if (this._events[type]) { delete this._events[type]; }\n\t\treturn this;\n\t}\n\n\t// emit removeListener for all listeners on all events\n\tif (arguments.length === 0) {\n\t\tfor (key in this._events) {\n\t\t\tif (key === \"removeListener\") { continue; }\n\t\t\tthis.removeAllListeners(key);\n\t\t}\n\t\tthis.removeAllListeners(\"removeListener\");\n\t\tthis._events = {};\n\t\treturn this;\n\t}\n\n\tlisteners = this._events[type];\n\n\tif (isFunction(listeners)) { this.removeListener(type, listeners); }\n\telse if (listeners) { while (listeners.length) { this.removeListener(type, listeners[listeners.length - 1]); } }\n\tdelete this._events[type];\n\n\treturn this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n\tvar ret;\n\tif (!this._events || !this._events[type]) { ret = []; }\n\telse if (isFunction(this._events[type])) { ret = [this._events[type]]; }\n\telse { ret = this._events[type].slice(); }\n\treturn ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n\tif (this._events) {\n\t\tvar evlistener = this._events[type];\n\n\t\tif (isFunction(evlistener)) { return 1; }\n\t\telse if (evlistener) { return evlistener.length; }\n\t}\n\treturn 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n\treturn emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n\treturn typeof arg === \"function\";\n}\n\nfunction isNumber(arg) {\n\treturn typeof arg === \"number\";\n}\n\nfunction isObject(arg) {\n\treturn typeof arg === \"object\" && arg !== null;\n}\n\nfunction isUndefined(arg) {\n\treturn arg === void 0;\n}\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/events.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/logger.js":
/*!*******************************************!*\
  !*** ./node_modules/tmi.js/lib/logger.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _ = __webpack_require__(/*! ./utils */ \"./node_modules/tmi.js/lib/utils.js\");\n\nvar currentLevel = \"info\";\nvar levels = { \"trace\": 0, \"debug\": 1, \"info\": 2, \"warn\": 3, \"error\": 4, \"fatal\": 5 };\n\n// Logger implementation..\nfunction log(level) {\n\t// Return a console message depending on the logging level..\n\treturn function(message) {\n\t\tif(levels[level] >= levels[currentLevel]) {\n\t\t\tconsole.log(`[${_.formatDate(new Date())}] ${level}: ${message}`);\n\t\t}\n\t}\n}\n\nmodule.exports = {\n\t// Change the current logging level..\n\tsetLevel(level) {\n\t\tcurrentLevel = level;\n\t},\n\ttrace: log(\"trace\"),\n\tdebug: log(\"debug\"),\n\tinfo: log(\"info\"),\n\twarn: log(\"warn\"),\n\terror: log(\"error\"),\n\tfatal: log(\"fatal\")\n};\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/logger.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/tmi.js/lib/parser.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n\tCopyright (c) 2013-2015, Fionn Kelleher All rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification,\n\tare permitted provided that the following conditions are met:\n\n\t\tRedistributions of source code must retain the above copyright notice,\n\t\tthis list of conditions and the following disclaimer.\n\n\t\tRedistributions in binary form must reproduce the above copyright notice,\n\t\tthis list of conditions and the following disclaimer in the documentation and/or other materials\n\t\tprovided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n\tANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\tWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n\tIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n\tINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\t(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n\tOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\tWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\tARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n\tOF SUCH DAMAGE.\n*/\nvar _ = __webpack_require__(/*! ./utils */ \"./node_modules/tmi.js/lib/utils.js\");\nvar nonspaceRegex = /\\S+/g;\n\nfunction parseComplexTag(tags, tagKey, splA = \",\", splB = \"/\", splC) {\n\tvar raw = tags[tagKey];\n\t\n\tif(raw === undefined) {\n\t\treturn tags;\n\t}\n\n\tvar tagIsString = _.isString(raw);\n\ttags[tagKey + \"-raw\"] = tagIsString ? raw : null;\n\n\tif(raw === true) {\n\t\ttags[tagKey] = null;\n\t\treturn tags;\n\t}\n\n\ttags[tagKey] = {};\n\n\tif(tagIsString) {\n\t\tvar spl = raw.split(splA);\n\n\t\tfor (var i = 0; i < spl.length; i++) {\n\t\t\tvar parts = spl[i].split(splB);\n\t\t\tvar val = parts[1];\n\t\t\tif(splC !== undefined && val) {\n\t\t\t\tval = val.split(splC);\n\t\t\t}\n\t\t\ttags[tagKey][parts[0]] = val || null;\n\t\t}\n\t}\n\treturn tags;\n}\n\nmodule.exports = {\n\t// Parse Twitch badges..\n\tbadges(tags) {\n\t\treturn parseComplexTag(tags, \"badges\");\n\t},\n\n\t// Parse Twitch badge-info..\n\tbadgeInfo(tags) {\n\t\treturn parseComplexTag(tags, \"badge-info\");\n\t},\n\n\t// Parse Twitch emotes..\n\temotes(tags) {\n\t\treturn parseComplexTag(tags, \"emotes\", \"/\", \":\", \",\");\n\t},\n\n\t// Parse regex emotes..\n\temoteRegex(msg, code, id, obj) {\n\t\tnonspaceRegex.lastIndex = 0;\n\t\tvar regex = new RegExp(\"(\\\\b|^|\\s)\" + _.unescapeHtml(code) + \"(\\\\b|$|\\s)\");\n\t\tvar match;\n\n\t\t// Check if emote code matches using RegExp and push it to the object..\n\t\twhile ((match = nonspaceRegex.exec(msg)) !== null) {\n\t\t\tif(regex.test(match[0])) {\n\t\t\t\tobj[id] = obj[id] || [];\n\t\t\t\tobj[id].push([match.index, nonspaceRegex.lastIndex - 1])\n\t\t\t}\n\t\t}\n\t},\n\n\t// Parse string emotes..\n\temoteString(msg, code, id, obj) {\n\t\tnonspaceRegex.lastIndex = 0;\n\t\tvar match;\n\n\t\t// Check if emote code matches and push it to the object..\n\t\twhile ((match = nonspaceRegex.exec(msg)) !== null) {\n\t\t\tif(match[0] === _.unescapeHtml(code)) {\n\t\t\t\tobj[id] = obj[id] || [];\n\t\t\t\tobj[id].push([match.index, nonspaceRegex.lastIndex - 1]);\n\t\t\t}\n\t\t}\n\t},\n\n\t// Transform the emotes object to a string with the following format..\n\t// emote_id:first_index-last_index,another_first-another_last/another_emote_id:first_index-last_index\n\ttransformEmotes(emotes) {\n\t\tvar transformed = \"\";\n\n\t\tObject.keys(emotes).forEach(id => {\n\t\t\ttransformed = `${transformed+id}:`;\n\t\t\temotes[id].forEach(\n\t\t\t\tindex => transformed = `${transformed+index.join(\"-\")},`\n\t\t\t);\n\t\t\ttransformed = `${transformed.slice(0,-1)}/`;\n\t\t});\n\n\t\treturn transformed.slice(0,-1);\n\t},\n\n\tformTags(tags) {\n\t\tvar result = [];\n\t\tfor(var key in tags) {\n\t\t\tvar value = _.escapeIRC(tags[key]);\n\t\t\tresult.push(`${key}=${value}`);\n\t\t}\n\t\treturn `@${result.join(';')}`;\n\t},\n\n\t// Parse Twitch messages..\n\tmsg(data) {\n\t\tvar message = {\n\t\t\traw: data,\n\t\t\ttags: {},\n\t\t\tprefix: null,\n\t\t\tcommand: null,\n\t\t\tparams: []\n\t\t}\n\n\t\t// Position and nextspace are used by the parser as a reference..\n\t\tvar position = 0;\n\t\tvar nextspace = 0;\n\n\t\t// The first thing we check for is IRCv3.2 message tags.\n\t\t// http://ircv3.atheme.org/specification/message-tags-3.2\n\t\tif(data.charCodeAt(0) === 64) {\n\t\t\tvar nextspace = data.indexOf(\" \");\n\n\t\t\t// Malformed IRC message..\n\t\t\tif(nextspace === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Tags are split by a semi colon..\n\t\t\tvar rawTags = data.slice(1, nextspace).split(\";\");\n\n\t\t\tfor (var i = 0; i < rawTags.length; i++) {\n\t\t\t\t// Tags delimited by an equals sign are key=value tags.\n\t\t\t\t// If there's no equals, we assign the tag a value of true.\n\t\t\t\tvar tag = rawTags[i];\n\t\t\t\tvar pair = tag.split(\"=\");\n\t\t\t\tmessage.tags[pair[0]] = tag.substring(tag.indexOf(\"=\") + 1) || true;\n\t\t\t}\n\n\t\t\tposition = nextspace + 1;\n\t\t}\n\n\t\t// Skip any trailing whitespace..\n\t\twhile (data.charCodeAt(position) === 32) {\n\t\t\tposition++;\n\t\t}\n\n\t\t// Extract the message's prefix if present. Prefixes are prepended with a colon..\n\t\tif(data.charCodeAt(position) === 58) {\n\t\t\tnextspace = data.indexOf(\" \", position);\n\n\t\t\t// If there's nothing after the prefix, deem this message to be malformed.\n\t\t\tif(nextspace === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tmessage.prefix = data.slice(position + 1, nextspace);\n\t\t\tposition = nextspace + 1;\n\n\t\t\t// Skip any trailing whitespace..\n\t\t\twhile (data.charCodeAt(position) === 32) {\n\t\t\t\tposition++;\n\t\t\t}\n\t\t}\n\n\t\tnextspace = data.indexOf(\" \", position);\n\n\t\t// If there's no more whitespace left, extract everything from the\n\t\t// current position to the end of the string as the command..\n\t\tif(nextspace === -1) {\n\t\t\tif(data.length > position) {\n\t\t\t\tmessage.command = data.slice(position);\n\t\t\t\treturn message;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// Else, the command is the current position up to the next space. After\n\t\t// that, we expect some parameters.\n\t\tmessage.command = data.slice(position, nextspace);\n\n\t\tposition = nextspace + 1;\n\n\t\t// Skip any trailing whitespace..\n\t\twhile (data.charCodeAt(position) === 32) {\n\t\t\tposition++;\n\t\t}\n\n\t\twhile (position < data.length) {\n\t\t\tnextspace = data.indexOf(\" \", position);\n\n\t\t\t// If the character is a colon, we've got a trailing parameter.\n\t\t\t// At this point, there are no extra params, so we push everything\n\t\t\t// from after the colon to the end of the string, to the params array\n\t\t\t// and break out of the loop.\n\t\t\tif(data.charCodeAt(position) === 58) {\n\t\t\t\tmessage.params.push(data.slice(position + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If we still have some whitespace...\n\t\t\tif(nextspace !== -1) {\n\t\t\t\t// Push whatever's between the current position and the next\n\t\t\t\t// space to the params array.\n\t\t\t\tmessage.params.push(data.slice(position, nextspace));\n\t\t\t\tposition = nextspace + 1;\n\n\t\t\t\t// Skip any trailing whitespace and continue looping.\n\t\t\t\twhile (data.charCodeAt(position) === 32) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If we don't have any more whitespace and the param isn't trailing,\n\t\t\t// push everything remaining to the params array.\n\t\t\tif(nextspace === -1) {\n\t\t\t\tmessage.params.push(data.slice(position));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn message;\n\t}\n}\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/parser.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/timer.js":
/*!******************************************!*\
  !*** ./node_modules/tmi.js/lib/timer.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Initialize the queue with a specific delay..\nfunction queue(defaultDelay) {\n\tthis.queue = [];\n\tthis.index = 0;\n\tthis.defaultDelay = defaultDelay || 3000;\n}\n\n// Add a new function to the queue..\nqueue.prototype.add = function add(fn, delay) {\n\tthis.queue.push({\n\t\tfn: fn,\n\t\tdelay: delay\n\t});\n};\n\n// Run the current queue..\nqueue.prototype.run = function run(index) {\n\t(index || index === 0) && (this.index = index);\n\tthis.next();\n};\n\n// Go to the next in queue..\nqueue.prototype.next = function next() {\n\tvar i = this.index++;\n\tvar at = this.queue[i];\n\tvar next = this.queue[this.index];\n\n\tif(!at) { return; }\n\n\tat.fn();\n\tnext && setTimeout(() => {\n\t\tthis.next();\n\t}, next.delay || this.defaultDelay);\n};\n\n// Reset the queue..\nqueue.prototype.reset = function reset() {\n\tthis.index = 0;\n};\n\n// Clear the queue..\nqueue.prototype.clear = function clear() {\n\tthis.index = 0;\n\tthis.queue = [];\n};\n\nexports.queue = queue;\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/timer.js?");

/***/ }),

/***/ "./node_modules/tmi.js/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/tmi.js/lib/utils.js ***!
  \******************************************/
/***/ ((module) => {

eval("var actionMessageRegex = /^\\u0001ACTION ([^\\u0001]+)\\u0001$/;\nvar justinFanRegex = /^(justinfan)(\\d+$)/;\nvar unescapeIRCRegex = /\\\\([sn:r\\\\])/g;\nvar escapeIRCRegex = /([ \\n;\\r\\\\])/g;\nvar ircEscapedChars = { s: ' ', n: '', ':': ';', r: '' };\nvar ircUnescapedChars = { ' ': 's', '\\n': 'n', ';': ':', '\\r': 'r' };\nvar self = module.exports = {\n\t// Return the second value if the first value is undefined..\n\tget: (obj1, obj2) => typeof obj1 === \"undefined\" ? obj2 : obj1,\n\n\t// Value is a boolean..\n\tisBoolean: obj => typeof obj === \"boolean\",\n\n\t// Value is a finite number..\n\tisFinite: int => isFinite(int) && !isNaN(parseFloat(int)),\n\n\t// Value is an integer..\n\tisInteger: int => !isNaN(self.toNumber(int, 0)),\n\n\t// Username is a justinfan username..\n\tisJustinfan: username => justinFanRegex.test(username),\n\n\t// Value is null..\n\tisNull: obj => obj === null,\n\n\t// Value is a regex..\n\tisRegex: str => /[\\|\\\\\\^\\$\\*\\+\\?\\:\\#]/.test(str),\n\n\t// Value is a string..\n\tisString: str => typeof(str) === \"string\",\n\n\t// Value is a valid url..\n\tisURL: str => new RegExp(\"^(?:(?:https?|ftp)://)(?:\\\\S+(?::\\\\S*)?@)?(?:(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?)(?::\\\\d{2,5})?(?:[/?#]\\\\S*)?$\",\"i\").test(str),\n\n\t// Return a random justinfan username..\n\tjustinfan: () => `justinfan${Math.floor((Math.random() * 80000) + 1000)}`,\n\n\t// Return a valid token..\n\ttoken: str => str ? str.toLowerCase().replace(\"oauth:\", \"\") : \"\",\n\n\t// Return a valid password..\n\tpassword: str => {\n\t\tconst token = self.token(str);\n\t\treturn token ? `oauth:${token}` : '';\n\t},\n\n\t// Race a promise against a delay..\n\tpromiseDelay: time => new Promise(resolve => setTimeout(resolve, time)),\n\n\t// Replace all occurences of a string using an object..\n\treplaceAll: (str, obj) => {\n\t\tif(str === null || typeof str === \"undefined\") {\n\t\t\treturn null;\n\t\t}\n\t\tfor (var x in obj) {\n\t\t\tstr = str.replace(new RegExp(x, \"g\"), obj[x]);\n\t\t}\n\t\treturn str;\n\t},\n\n\tunescapeHtml: safe =>\n\t\tsafe.replace(/\\\\&amp\\\\;/g, \"&\")\n\t\t\t.replace(/\\\\&lt\\\\;/g, \"<\")\n\t\t\t.replace(/\\\\&gt\\\\;/g, \">\")\n\t\t\t.replace(/\\\\&quot\\\\;/g, \"\\\"\")\n\t\t\t.replace(/\\\\&#039\\\\;/g, \"'\"),\n\n\t// Escaping values:\n\t// http://ircv3.net/specs/core/message-tags-3.2.html#escaping-values\n\tunescapeIRC: msg => !msg || !msg.includes('\\\\') ?\n\t\tmsg :\n\t\tmsg.replace(\n\t\t\tunescapeIRCRegex,\n\t\t\t(m, p) => p in ircEscapedChars ? ircEscapedChars[p] : p\n\t\t),\n\t\n\tescapeIRC: msg => !msg ? msg :\n\t\tmsg.replace(\n\t\t\tescapeIRCRegex,\n\t\t\t(m, p) => p in ircUnescapedChars ? `\\\\${ircUnescapedChars[p]}` : p\n\t\t),\n\n\tactionMessage: msg => msg.match(actionMessageRegex),\n\n\t// Add word to a string..\n\taddWord: (line, word) => line.length ? line + \" \" + word : line + word,\n\n\t// Return a valid channel name..\n\tchannel: str => {\n\t\tvar channel = (str ? str : \"\").toLowerCase();\n\t\treturn channel[0] === \"#\" ? channel : \"#\" + channel;\n\t},\n\n\t// Extract a number from a string..\n\textractNumber: str => {\n\t\tvar parts = str.split(\" \");\n\t\tfor (var i = 0; i < parts.length; i++) {\n\t\t\tif(self.isInteger(parts[i])) {\n\t\t\t\treturn ~~parts[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Format the date..\n\tformatDate: date => {\n\t\tvar hours = date.getHours();\n\t\tvar mins  = date.getMinutes();\n\n\t\thours = (hours < 10 ? \"0\" : \"\") + hours;\n\t\tmins = (mins < 10 ? \"0\" : \"\") + mins;\n\n\t\treturn `${hours}:${mins}`;\n\t},\n\n\t// Inherit the prototype methods from one constructor into another..\n\tinherits: (ctor, superCtor) => {\n\t\tctor.super_ = superCtor\n\t\tvar TempCtor = function () {};\n\t\tTempCtor.prototype = superCtor.prototype;\n\t\tctor.prototype = new TempCtor();\n\t\tctor.prototype.constructor = ctor;\n\t},\n\n\t// Return whether inside a Node application or not..\n\tisNode: () => {\n\t\ttry {\n\t\t\treturn \"object\" === typeof process &&\n\t\t\t\tObject.prototype.toString.call(process) === \"[object process]\";\n\t\t} catch(e) {}\n\t\treturn false;\n\t},\n\n\t// Merge two objects..\n\tmerge: Object.assign,\n\n\t// Split a line but try not to cut a word in half..\n\tsplitLine: (input, length) => {\n\t\tvar lastSpace = input.substring(0, length).lastIndexOf(\" \");\n\t\t// No spaces found, split at the very end to avoid a loop..\n\t\tif(lastSpace === -1) {\n\t\t\tlastSpace = length - 1;\n\t\t}\n\t\treturn [input.substring(0, lastSpace), input.substring(lastSpace + 1)];\n\t},\n\n\t// Parse string to number. Returns NaN if string can't be parsed to number..\n\ttoNumber: (num, precision) => {\n\t\tif(num === null) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar factor = Math.pow(10, self.isFinite(precision) ? precision : 0);\n\t\treturn Math.round(num * factor) / factor;\n\t},\n\n\t// Merge two arrays..\n\tunion: (a, b) => [ ...new Set([ ...a, ...b ]) ],\n\n\t// Return a valid username..\n\tusername: str => {\n\t\tvar username = (str ? str : \"\").toLowerCase();\n\t\treturn username[0] === \"#\" ? username.slice(1) : username;\n\t}\n}\n\n\n//# sourceURL=webpack://honk-overlay/./node_modules/tmi.js/lib/utils.js?");

/***/ }),

/***/ "./src/horn.js":
/*!*********************!*\
  !*** ./src/horn.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Horn)\n/* harmony export */ });\nclass Horn {\r\n  /**\r\n   * A drawable spinning, floating horn.\r\n   * @constructor\r\n   * @param {CanvasRenderingContext2D} context - The rendering context being \r\n   * drawn to.\r\n   * @param {HTMLImageElement} image - the image to be drawn.\r\n   * @param {Object} options - an optional options object.\r\n   */\r\n  constructor(context, image, options = {}) {\r\n    // Assert context exists because it is manditory\r\n    if (context instanceof CanvasRenderingContext2D) {\r\n      this.context = context;\r\n    } else {\r\n      throw new TypeError(\r\n        `Expected context to be a CanvasRenderingContext2D. Found: ${typeof context}`\r\n      );\r\n    }\r\n\r\n    // Assert image exists because it is manditory\r\n    if (image instanceof HTMLImageElement) {\r\n      this.image = image;\r\n    } else {\r\n      throw new TypeError(\r\n        `Expected image to be a HTMLImageElement. Found: ${typeof image}`\r\n      );\r\n    }\r\n\r\n    const { width: canvasWidth, height: canvasHeight } = context.canvas;\r\n    // Create an offset in the range of [-1/4pi, 1/4pi]\r\n    const angleOffset = (Math.random() - 0.5) * (Math.PI / 2);\r\n    // The speed to be used as the magnitiude of the velocity vector.\r\n    const speed = Math.random() * canvasWidth;\r\n    // Which side of the screen the horn is going to appear on\r\n    const isLeft = Math.random() < 0.5;\r\n    // An angle pointing right if it is spawning on the left side, or vice-versa\r\n    // with the offset added\r\n    const angle = Math.PI * (isLeft + 0.5) + angleOffset;\r\n    // The aspect ratio of the image in case the height is not specified in the\r\n    // options object\r\n    const aspectRatio = image.height / image.width;\r\n\r\n    const {\r\n      // width in pixels\r\n      width = 48,\r\n      // height in pixels\r\n      height = width * aspectRatio,\r\n      // minimum time to live in milliseconds\r\n      minTTL = 3000,\r\n      // maximum time to live in milliseconds\r\n      maxTTL = 5000,\r\n      // maximum rotation speed in rotations per second\r\n      maxRotationSpeed = 4,\r\n    } = options;\r\n\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    this.createdAt = performance.now();\r\n\r\n    this.timeToLive = minTTL + Math.random() * (maxTTL - minTTL);\r\n\r\n    this.position = {\r\n      x: isLeft * canvasWidth,\r\n      // somewhere in them middle half\r\n      y: canvasHeight / 2 + (Math.random() - 0.5) * (canvasHeight / 2),\r\n    };\r\n\r\n    // create a unit vector from the angle, multiplied by the speed\r\n    this.velocity = {\r\n      x: Math.sin(angle) * speed,\r\n      y: Math.cos(angle) * speed,\r\n    };\r\n\r\n    // multiply the rotation speed by a number in the range of [-2pi, 2pi]\r\n    this.rotationSpeed = (Math.random() * 4 - 2) * Math.PI * maxRotationSpeed;\r\n    this.rotation = 0;\r\n  }\r\n\r\n  /**\r\n   * Checks if the horn is still \"alive\" and should update.\r\n   * @returns {Boolean}\r\n   */\r\n  shouldUpdate() {\r\n    return performance.now() - this.createdAt < this.timeToLive;\r\n  }\r\n\r\n  /**\r\n   * Updates the positional properies of the horn.\r\n   * @param {Number} deltaTime - the time in milliseconds since last update.\r\n   */\r\n  update(deltaTime) {\r\n    const { position, velocity, rotationSpeed } = this;\r\n    const dtInSeconds = deltaTime / 1000;\r\n\r\n    position.x += velocity.x * dtInSeconds;\r\n    position.y += velocity.y * dtInSeconds;\r\n\r\n    this.rotation += rotationSpeed * dtInSeconds;\r\n  }\r\n\r\n  /**\r\n   * Draws the horn to the rendering context.\r\n   */\r\n  draw() {\r\n    const { context, position, rotation, image, width, height } = this;\r\n    context.save();\r\n\r\n    context.translate(position.x, position.y);\r\n    context.rotate(rotation);\r\n\r\n    // Draw the image with the center of the image at the current origin\r\n    context.drawImage(image, -width / 2, -height / 2, width, height);\r\n\r\n    context.restore();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://honk-overlay/./src/horn.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _horn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./horn.js */ \"./src/horn.js\");\n/* harmony import */ var tmi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tmi.js */ \"./node_modules/tmi.js/index.js\");\n/* harmony import */ var tmi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tmi_js__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\n// TODO: Allow the user to configure the channel being connected to\r\nconst twitchChannel = \"angryknees\";\r\n\r\n// the URLs to fetch the horn images from\r\nconst hornImageURLs = [\r\n  \"assets/images/horn.png\",\r\n  \"assets/images/textHorn.png\",\r\n  \"assets/images/clown.png\",\r\n  \"https://static-cdn.jtvnw.net/emoticons/v2/303562626/default/dark/2.0\",\r\n];\r\n\r\n// the URLs to fetch the horn audio files from\r\nconst hornAudioURLs = [\r\n  \"assets/sound/bikehorn.ogg\", \r\n  \"assets/sound/airhorn.ogg\", \r\n  \"assets/sound/airhorn2.ogg\"\r\n];\r\n\r\nwindow.onload = async () => {\r\n  const canvas = document.querySelector(\"#canvas\");\r\n  const canvasContext = canvas.getContext(\"2d\");\r\n  const audioContext = new AudioContext();\r\n  let horns = [];\r\n\r\n  const client = new (tmi_js__WEBPACK_IMPORTED_MODULE_1___default().Client)({\r\n    connection: { reconnect: true },\r\n    channels: [twitchChannel],\r\n  });\r\n\r\n  // Download all the images and audio files, and connect to twitch,\r\n  // at the same time\r\n  const [\r\n    hornImage,\r\n    textHornImage,\r\n    clownImage,\r\n    twitchHornImage,\r\n    bikeHornBuffer,\r\n    airHornBuffer,\r\n    airHorn2Buffer,\r\n  ] = await Promise.all([\r\n    ...hornImageURLs.map(fetchImage),\r\n    ...hornAudioURLs.map(fetchAudioBuffer.bind(undefined, audioContext)),\r\n    client.connect(),\r\n  ]);\r\n\r\n  client.on(\"message\", handleMessage);\r\n\r\n  resizeCanvasToDisplaySize(canvas);\r\n\r\n  let lastTime = performance.now();\r\n\r\n  // start the animation loop\r\n  requestAnimationFrame(draw);\r\n\r\n  /**\r\n   * The core function of the animation loop.\r\n   * @param {DOMHighResTimeStamp} time - Provided by requestAnimationFrame.\r\n   */\r\n  function draw(time) {\r\n    // Make sure the canvas's buffer dimentions fit it's display dimentions.\r\n    // We call it every tick as an alternative to the resize event to avoid the\r\n    // wonkiness of the resize event\r\n    resizeCanvasToDisplaySize(canvas);\r\n\r\n    // Clear the entire canvas\r\n    canvasContext.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Remove horns that shouldn't update\r\n    horns = horns.filter((horn) => horn.shouldUpdate());\r\n\r\n    // Update and draw all of the \"alive\" horns\r\n    const dt = time - lastTime;\r\n    horns.forEach((horn) => {\r\n      horn.update(dt);\r\n      horn.draw();\r\n    });\r\n\r\n    lastTime = time;\r\n\r\n    // Queue up the next iteration of the loop\r\n    requestAnimationFrame(draw);\r\n  }\r\n\r\n  /**\r\n   * The logic for handling twitch messages and therefore listening for when to\r\n   * spawn horns. Listens for the tmi.js Message event.\r\n   * @see {@link https://github.com/tmijs/docs/blob/gh-pages/_posts/v1.4.2/2019-03-03-Events.md#message}\r\n   */\r\n  function handleMessage(channel, userstate, message, self) {\r\n    // Check if the message contains \"russmoHORN\" or \"russmoHONK\".\r\n    // TODO: Allow the user to configure the trigger emotes.\r\n    if (/russmoHORN|russmoHONK/.test(message)) {\r\n      // Could be worth extacting this logic into a Role class that has a list\r\n      // of images, sounds, and a isUserRole function that tests against the\r\n      // userstate. However at the current scale that would create more\r\n      // complexity than it'd remove.\r\n\r\n      // Default to the \"poverty horn\" and the SS13 bikehorn noise.\r\n      let image = textHornImage;\r\n      let audioBuffer = bikeHornBuffer;\r\n\r\n      const { badges } = userstate;\r\n\r\n      // Check if the messager is the broadcaster.\r\n      if (badges && badges.broadcaster) {\r\n        image = clownImage;\r\n        // Randomly pick between the two airhorn noises.\r\n        audioBuffer = Math.random() > 0.5 ? airHornBuffer : airHorn2Buffer;\r\n        // Check if the messager is a subscriber.\r\n      } else if (userstate.subscriber) {\r\n        // Randomly pick between the SS13 bikehorn icon, or the russmoHorn icon.\r\n        image = Math.random() > 0.5 ? hornImage : twitchHornImage;\r\n      }\r\n\r\n      // Add a new horn to screen with the selected image.\r\n      horns.push(new _horn_js__WEBPACK_IMPORTED_MODULE_0__.default(canvasContext, image));\r\n\r\n      // Play the selected horn noise. Hopefully this will be the airhorn.\r\n      playAudioBuffer(audioContext, audioBuffer);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch an image as an HTMLImageElement that is loaded before resolution.\r\n * @param {String} url - The address of the image to fetch.\r\n * @returns {HTMLImageElement}\r\n */\r\nasync function fetchImage(url) {\r\n  const res = await fetch(url);\r\n  const blob = await res.blob();\r\n  const blobUrl = URL.createObjectURL(blob);\r\n\r\n  const image = new Image();\r\n  image.src = blobUrl;\r\n\r\n  return image;\r\n}\r\n\r\n/**\r\n * Fetches an audio file as a decoded audio buffer.\r\n * @param {AudioContext} context - The context handling the audio file.\r\n * @param {String} url - The address of the sound file to fetch.\r\n * @returns {AudioBuffer}\r\n */\r\nasync function fetchAudioBuffer(context, url) {\r\n  const res = await fetch(url);\r\n  const rawBuffer = await res.arrayBuffer();\r\n  return await context.decodeAudioData(rawBuffer);\r\n}\r\n\r\n/**\r\n * Plays a sound from an AudioBuffer.\r\n * @param {AudioContext} context - The context to play the file at.\r\n * @param {AudioBuffer} buffer - The sound to be played.\r\n */\r\nfunction playAudioBuffer(context, buffer) {\r\n  // AudioBufferSourceNodes can only be used once.\r\n  const source = context.createBufferSource();\r\n  source.buffer = buffer;\r\n  source.connect(context.destination);\r\n  source.start();\r\n}\r\n\r\n/**\r\n * Resize a Canvas's buffer size to its display size.\r\n * @param {HTMLCanvasElement} canvas\r\n */\r\nfunction resizeCanvasToDisplaySize(canvas) {\r\n  // Ensure it needs to be resized before resizing.\r\n  if (canvas.width !== canvas.clientWidth) {\r\n    canvas.width = canvas.clientWidth;\r\n  }\r\n  if (canvas.height !== canvas.clientHeight) {\r\n    canvas.height = canvas.clientHeight;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://honk-overlay/./src/index.js?");

/***/ }),

/***/ "?7581":
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://honk-overlay/node-fetch_(ignored)?");

/***/ }),

/***/ "?98fa":
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://honk-overlay/ws_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;